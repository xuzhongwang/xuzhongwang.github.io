<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/32/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-CSS入门及提高" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/21/CSS入门及提高/" class="article-date">
  <time datetime="2018-07-21T06:30:58.000Z" itemprop="datePublished">2018-07-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/21/CSS入门及提高/">CSS入门及提高</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-CSS-样式规则"><a href="#1-CSS-样式规则" class="headerlink" title="1. CSS 样式规则"></a>1. CSS 样式规则</h1><p><img src="/2018/07/21/CSS入门及提高/CSS样式规则.png" alt="CSS入门及提高"></p>
<h1 id="2-字体设置"><a href="#2-字体设置" class="headerlink" title="2. 字体设置"></a>2. 字体设置</h1><h2 id="2-1-字体综合设置"><a href="#2-1-字体综合设置" class="headerlink" title="2.1. 字体综合设置"></a>2.1. 字体综合设置</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择器 &#123;<span class="attribute">font</span>: font-style font-weight font-size/line-weight font-family;&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li><p>顺序不能变.</p>
</li>
<li><p>不需要设置的属性可以省略，取默认值，但必须保留 font-size 与 font-family</p>
</li>
</ul>
<h2 id="2-2-input提示"><a href="#2-2-input提示" class="headerlink" title="2.2. input提示"></a>2.2. input提示</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"请输入内容"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="3-选择器"><a href="#3-选择器" class="headerlink" title="3. 选择器"></a>3. 选择器</h1><h2 id="3-1-标签选择器（元素选择器）"><a href="#3-1-标签选择器（元素选择器）" class="headerlink" title="3.1. 标签选择器（元素选择器）"></a>3.1. 标签选择器（元素选择器）</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">标签名 &#123; 属性1:属性值1;属性2：属性值2&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-类选择器"><a href="#3-2-类选择器" class="headerlink" title="3.2. 类选择器"></a>3.2. 类选择器</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.类名 &#123;属性1:属性值1;属性2：属性值2&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-3-id-选择器"><a href="#3-3-id-选择器" class="headerlink" title="3.3. id 选择器"></a>3.3. id 选择器</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#id名 &#123;属性1:属性值1;属性2：属性值2&#125;</span><br></pre></td></tr></table></figure>
<p>id 选择器与 类选择器的区别：在使用次数上，类选择器可以使用多次，id 选择器只能使用一次</p>
<h2 id="3-4-通配符选择器"><a href="#3-4-通配符选择器" class="headerlink" title="3.4. 通配符选择器"></a>3.4. 通配符选择器</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* &#123;属性1:属性值1;属性2：属性值2&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-5-伪类选择器"><a href="#3-5-伪类选择器" class="headerlink" title="3.5. 伪类选择器"></a>3.5. 伪类选择器</h2><h3 id="3-5-1-链接伪类选择器"><a href="#3-5-1-链接伪类选择器" class="headerlink" title="3.5.1. 链接伪类选择器"></a>3.5.1. 链接伪类选择器</h3><ul>
<li>:link  未访问的链接</li>
<li>:visited 已访问的链接</li>
<li>:hover 鼠标移动到链接上</li>
<li>:active 选定的链接，选定不松开时</li>
</ul>
<p>注意：顺序不能颠倒</p>
<h3 id="3-5-2-结构伪类选择器"><a href="#3-5-2-结构伪类选择器" class="headerlink" title="3.5.2. 结构伪类选择器"></a>3.5.2. 结构伪类选择器</h3><ul>
<li>:first-child 选取属于其父元素的首个子元素的指定选择器</li>
<li>:last-child 选取属于其父元素的最后一个子元素的指定选择器</li>
<li>:nth-child(n)  选取第n个,n从0开始,n可以是公式</li>
<li>:nth-last-child(n) 从最后一个元素开始,</li>
</ul>
<h3 id="3-5-3-目标伪类选择器"><a href="#3-5-3-目标伪类选择器" class="headerlink" title="3.5.3. 目标伪类选择器"></a>3.5.3. 目标伪类选择器</h3><p>:target 目标伪类选择器，选择器可用于选取当前活动的目标元素。</p>
<h1 id="4-文字"><a href="#4-文字" class="headerlink" title="4. 文字"></a>4. 文字</h1><h2 id="4-1-文字阴影"><a href="#4-1-文字阴影" class="headerlink" title="4.1. 文字阴影"></a>4.1. 文字阴影</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">text-shadow</span>: 水平位置，垂直位置，模糊距离，阴影颜色</span><br></pre></td></tr></table></figure>
<h2 id="4-2-文本的装饰"><a href="#4-2-文本的装饰" class="headerlink" title="4.2. 文本的装饰"></a>4.2. 文本的装饰</h2><table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>none</td>
<td>默认，定义标准的文本</td>
</tr>
<tr>
<td>underline</td>
<td>定义文本下的一条线</td>
</tr>
<tr>
<td>overline</td>
<td>定义文本上的一条线</td>
</tr>
<tr>
<td>line-through</td>
<td>定义穿过文本下的一条线</td>
</tr>
</tbody>
</table>
<h1 id="5-css样式表"><a href="#5-css样式表" class="headerlink" title="5. css样式表"></a>5. css样式表</h1><table>
<thead>
<tr>
<th>样式表</th>
<th>优点</th>
<th>缺点</th>
<th>使用情况</th>
<th>控制范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>内部样式表</td>
<td>书写方便，权重高</td>
<td>没有实现样式和结构相分离</td>
<td>较少</td>
<td>控制一个标签（少） </td>
</tr>
<tr>
<td>行内样式表</td>
<td>部分结构与样式分离</td>
<td>没有彻底分离</td>
<td>较多</td>
<td>控制一个页面（中）</td>
</tr>
<tr>
<td>外部样式表</td>
<td>完全实现结构与样式分离</td>
<td>需要引入</td>
<td>最多，强烈推荐</td>
<td>控制整个站点（多）</td>
</tr>
</tbody>
</table>
<h2 id="5-1-标签的显示形式"><a href="#5-1-标签的显示形式" class="headerlink" title="5.1. 标签的显示形式"></a>5.1. 标签的显示形式</h2><p>HTML 标签一般分为块标签和行内标签两种类型，它们也称块元素和行内元素</p>
<h3 id="5-1-1-块级元素"><a href="#5-1-1-块级元素" class="headerlink" title="5.1.1. 块级元素"></a>5.1.1. 块级元素</h3><p>每个块级元素通常都会独自占据一整行或多行，可以对其设置宽度、高度、对齐等属性，常用于网页布局和网页结构搭建。</p>
<p>常见的元素有：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">h1</span>&gt;...&lt;<span class="selector-tag">h6</span>&gt;、&lt;<span class="selector-tag">p</span>&gt;、&lt;<span class="selector-tag">div</span>&gt;、&lt;<span class="selector-tag">ul</span>&gt;、&lt;<span class="selector-tag">ol</span>&gt;、&lt;<span class="selector-tag">li</span>&gt;等</span><br></pre></td></tr></table></figure>
<p>特点：</p>
<ul>
<li>总是从新行开始</li>
<li>宽度、行高、外边距及内边距都可以控制</li>
<li>宽度默认是容器的100%</li>
<li>可以容纳其它内联元素和其他块元素</li>
</ul>
<h3 id="5-1-2-行内元素"><a href="#5-1-2-行内元素" class="headerlink" title="5.1.2. 行内元素"></a>5.1.2. 行内元素</h3><p>行内元素（内联元素）不占有独立的区域，仅仅靠自身的字体大小和图像尺寸来支撑结构，一般不可以设置宽度、高度、对齐等属性，常用开控制页面中文本的样式。</p>
<p>常见的行内元素有</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">a</span>&gt; &lt;<span class="selector-tag">strong</span>&gt; &lt;<span class="selector-tag">b</span>&gt; &lt;<span class="selector-tag">em</span>&gt; &lt;<span class="selector-tag">i</span>&gt; &lt;<span class="selector-tag">del</span>&gt; &lt;<span class="selector-tag">ins</span>&gt; &lt;<span class="selector-tag">u</span>&gt; &lt;<span class="selector-tag">span</span>&gt;</span><br></pre></td></tr></table></figure>
<p>特点：</p>
<ul>
<li>和相邻行内元素在一行内显示</li>
<li>高、宽无效，但水平方向的 padding 和 margin 可以设置，垂直方向的无效。</li>
<li>默认宽度就是它本身内容的宽度</li>
<li>行内元素只能容纳文本或者其他行内元素（a特殊)</li>
</ul>
<p>注意：</p>
<ul>
<li>只有文字能组成段落，因此 p 里面不能放块级元素，同理 h1~h6</li>
<li>链接里面不能再放链接</li>
</ul>
<h3 id="5-1-3-行内块元素-inline-block"><a href="#5-1-3-行内块元素-inline-block" class="headerlink" title="5.1.3. 行内块元素(inline-block)"></a>5.1.3. 行内块元素(inline-block)</h3><p>在行内元素中有几个特殊的标签 &lt;img/&gt;、&lt;input/&gt;、&lt;td&gt; 可以对它们设置宽度和对齐属性</p>
<p>特点：</p>
<ul>
<li>和相邻行内元素（行内块）在一行上，但是之间会有空白缝隙。</li>
<li>默认宽度就是它本身内容的宽度（宽度由内容决定）</li>
<li>高度，行高，外边距以及内边距都可以控制。</li>
</ul>
<h3 id="5-1-4-显示模式转换"><a href="#5-1-4-显示模式转换" class="headerlink" title="5.1.4. 显示模式转换"></a>5.1.4. 显示模式转换</h3><p>块转行内： display:inline;<br>行内转块： display:block;<br>块、行内元素转行内块： display:inline-block;</p>
<h1 id="6-复合选择器"><a href="#6-复合选择器" class="headerlink" title="6. 复合选择器"></a>6. 复合选择器</h1><h2 id="6-1-交集选择器"><a href="#6-1-交集选择器" class="headerlink" title="6.1. 交集选择器"></a>6.1. 交集选择器</h2><p><img src="/2018/07/21/CSS入门及提高/交集选择器.png" alt="交集选择器"></p>
<h2 id="6-2-并集选择器"><a href="#6-2-并集选择器" class="headerlink" title="6.2. 并集选择器"></a>6.2. 并集选择器</h2><p><img src="/2018/07/21/CSS入门及提高/并集选择器.png" alt="并集选择器"></p>
<h2 id="6-3-后代选择器"><a href="#6-3-后代选择器" class="headerlink" title="6.3. 后代选择器"></a>6.3. 后代选择器</h2><p><img src="/2018/07/21/CSS入门及提高/后代选择器.png" alt="后代选择器"></p>
<h2 id="6-4-子元素选择器"><a href="#6-4-子元素选择器" class="headerlink" title="6.4. 子元素选择器"></a>6.4. 子元素选择器</h2><p><img src="/2018/07/21/CSS入门及提高/子元素选择器.png" alt="子元素选择器"></p>
<h2 id="6-5-属性选择器"><a href="#6-5-属性选择器" class="headerlink" title="6.5. 属性选择器"></a>6.5. 属性选择器</h2><p>选取标签带有某些特殊属性的选择器</p>
<table>
<thead>
<tr>
<th>选择器</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>E[attr]</td>
<td>存在 attr 属性即可</td>
</tr>
<tr>
<td>E[attr=val]</td>
<td>属性值完全等于 val</td>
</tr>
<tr>
<td>E[attr*=val]</td>
<td>属性值包含 val 字符并且在“任意”位置</td>
</tr>
<tr>
<td>E[attr^=val]</td>
<td>属性值包含 val 字符并且在“开始”位置</td>
</tr>
<tr>
<td>E[attr$=val]</td>
<td>属性值包含 val 字符并且在“结束”位置</td>
</tr>
</tbody>
</table>
<h2 id="6-6-伪元素选择器（CSS3"><a href="#6-6-伪元素选择器（CSS3" class="headerlink" title="6.6. 伪元素选择器（CSS3)"></a>6.6. 伪元素选择器（CSS3)</h2><ul>
<li>E::first-letter 文本的第一个单词或字</li>
<li>E::first-line 文本第一行</li>
<li>E::selection 可改变选中文本的样式</li>
<li>E::before和 E::after 在E元素内部开始的位置和结束位创建一个元素，该元素为行内元素，且必须结合content属性使用</li>
</ul>
<h1 id="7-CSS-书写规范"><a href="#7-CSS-书写规范" class="headerlink" title="7. CSS 书写规范"></a>7. CSS 书写规范</h1><h2 id="7-1-空格规范"><a href="#7-1-空格规范" class="headerlink" title="7.1. 空格规范"></a>7.1. 空格规范</h2><p>【强制】选择器与{}之间必须包含空格<br>【强制】属性名与之后的：之间不允许包含空格，：与属性值之间必须包含空格.<br>示例：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">font-size</span>: 12<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure>
<h2 id="7-2-选择器规范"><a href="#7-2-选择器规范" class="headerlink" title="7.2. 选择器规范"></a>7.2. 选择器规范</h2><p>【强制】当一个 rule 包含多个 selector 时，每个选择器声明必须独占一行。<br>【建议】选择器嵌套层级不大于3级，位置靠后的限定条件应尽可能精确。</p>
<h2 id="7-3-属性规范"><a href="#7-3-属性规范" class="headerlink" title="7.3. 属性规范"></a>7.3. 属性规范</h2><p>【强制】属性定义必须另起一行<br>【强制】属性定义后必须以分号结尾</p>
<h1 id="8-CSS-背景"><a href="#8-CSS-背景" class="headerlink" title="8. CSS 背景"></a>8. CSS 背景</h1><h2 id="8-1-多背景"><a href="#8-1-多背景" class="headerlink" title="8.1. 多背景"></a>8.1. 多背景</h2><ul>
<li>一个元素可以设置多重背景图像</li>
<li>每组属性之间使用逗号隔开</li>
<li>如果设置的多重背景之间存在着交集（即存在着重叠关系），前面的背景图片会覆盖在后面的背景图片上。</li>
<li>为了避免背景色将图像盖住，背景色通常定义在最后一组上。</li>
</ul>
<h1 id="9-CSS-三大特性"><a href="#9-CSS-三大特性" class="headerlink" title="9. CSS 三大特性"></a>9. CSS 三大特性</h1><h2 id="9-1-层叠性"><a href="#9-1-层叠性" class="headerlink" title="9.1. 层叠性"></a>9.1. 层叠性</h2><p>样式冲突遵循的原则是就近原则，哪个样式离着结构近就执行哪个样式。</p>
<h2 id="9-2-继承性"><a href="#9-2-继承性" class="headerlink" title="9.2. 继承性"></a>9.2. 继承性</h2><p>子元素可以继承父元素的样式，如 text- font- line- 以及 color属性</p>
<h2 id="9-3-优先性"><a href="#9-3-优先性" class="headerlink" title="9.3. 优先性"></a>9.3. 优先性</h2><p>权重表</p>
<table>
<thead>
<tr>
<th>继承或者*的贡献值</th>
<th>0,0,0,0</th>
</tr>
</thead>
<tbody>
<tr>
<td>每个元素（标签）贡献值为</td>
<td>0,0,0,1</td>
</tr>
<tr>
<td>每个类、伪类贡献值为</td>
<td>0,0,1,0</td>
</tr>
<tr>
<td>每个ID贡献值为</td>
<td>0,１,0,0</td>
</tr>
<tr>
<td>每个行内样式贡献值为</td>
<td>1,0,0,0</td>
</tr>
<tr>
<td>每个!important贡献值为</td>
<td>无穷大</td>
</tr>
</tbody>
</table>
<p>继承的权重为0</p>
<h1 id="10-盒子模型"><a href="#10-盒子模型" class="headerlink" title="10. 盒子模型"></a>10. 盒子模型</h1><h2 id="10-1-外边距合并"><a href="#10-1-外边距合并" class="headerlink" title="10.1. 外边距合并"></a>10.1. 外边距合并</h2><h3 id="10-1-1-相邻元素块垂直外边距合并"><a href="#10-1-1-相邻元素块垂直外边距合并" class="headerlink" title="10.1.1. 相邻元素块垂直外边距合并"></a>10.1.1. 相邻元素块垂直外边距合并</h3><p>不是两者相加的和，而是取两者中的较大者。</p>
<h3 id="10-1-2-嵌套元素垂直外边距合并"><a href="#10-1-2-嵌套元素垂直外边距合并" class="headerlink" title="10.1.2. 嵌套元素垂直外边距合并"></a>10.1.2. 嵌套元素垂直外边距合并</h3><p>对于两个嵌套关系的块元素，如果父元素没有上边距及边框，则父元素的上边距会与子元素的上边距发生合并，合并后的外边距为两者中的较大者。</p>
<p>解决方案：</p>
<ul>
<li>可以为父元素定义1像素的上边框或上内边距。</li>
<li>可以为父元素添加overflow:hidden</li>
</ul>
<h2 id="10-2-盒子的计算尺寸"><a href="#10-2-盒子的计算尺寸" class="headerlink" title="10.2. 盒子的计算尺寸"></a>10.2. 盒子的计算尺寸</h2><p>注意：</p>
<ul>
<li>宽度属性和高度属性仅适用于块级元素，对行内元素无效（img标签和input除外）</li>
<li>计算盒子模型的总高度时，还应考虑上下两个盒子垂直外边距合并的情况</li>
<li>如果一个盒子没有给定宽度/高度或者继承父亲的宽度/高度,则padding不会影响本盒子大小。</li>
</ul>
<h2 id="10-3-盒子模型与布局稳定性"><a href="#10-3-盒子模型与布局稳定性" class="headerlink" title="10.3. 盒子模型与布局稳定性"></a>10.3. 盒子模型与布局稳定性</h2><p>稳定性<br>width &gt; padding &gt; margin</p>
<h2 id="10-4-CSS3-盒模型"><a href="#10-4-CSS3-盒模型" class="headerlink" title="10.4. CSS3 盒模型"></a>10.4. CSS3 盒模型</h2><ol>
<li>box-sizing:content-box 盒子大小为 width + padding + border ,此值为默认值，W2C标准的Box Mode</li>
<li>box-sizing:border-box 盒子大小为 width</li>
</ol>
<h2 id="10-5-盒子阴影"><a href="#10-5-盒子阴影" class="headerlink" title="10.5. 盒子阴影"></a>10.5. 盒子阴影</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">box-shadow</span> 水平位置 垂直位置 模糊距离 阴影尺寸 阴影颜色  内外阴影</span><br></pre></td></tr></table></figure>
<h2 id="10-6-浮动"><a href="#10-6-浮动" class="headerlink" title="10.6. 浮动"></a>10.6. 浮动</h2><p>CSS 定位机制有3种：普通流（标准流）、浮动和定位</p>
<ul>
<li>普通流(normal flow) ：自上而下，自左而右</li>
<li>浮动：最开始用来做文字环绕效果</li>
</ul>
<h3 id="10-6-1-什么是浮动"><a href="#10-6-1-什么是浮动" class="headerlink" title="10.6.1. 什么是浮动"></a>10.6.1. 什么是浮动</h3><p>元素浮动是指设置了浮动属性的元素会脱离标准普通流的控制，移动到其父元素中指定位置的过程。</p>
<h3 id="10-6-2-浮动与行内块"><a href="#10-6-2-浮动与行内块" class="headerlink" title="10.6.2. 浮动与行内块"></a>10.6.2. 浮动与行内块</h3><p>行内块之间有难以却除的间隙<br>行内元素或块级元素添加浮动后变为行内块</p>
<h2 id="10-7-版心和布局流程"><a href="#10-7-版心和布局流程" class="headerlink" title="10.7. 版心和布局流程"></a>10.7. 版心和布局流程</h2><ul>
<li>确定页面的版心</li>
<li>分析页面中的行模块，以及每个行模块中的列模块</li>
<li>制作HTML结构</li>
<li>CSS初始化，然后开始运用盒子模型的原理，通过 DIV+CSS布局来控制网页中的各个模块。</li>
</ul>
<h3 id="10-7-1-清除浮动的本质"><a href="#10-7-1-清除浮动的本质" class="headerlink" title="10.7.1. 清除浮动的本质"></a>10.7.1. 清除浮动的本质</h3><p>清除浮动主要是为了解决父级元素因为子级浮动引起内部高度为0的问题。</p>
<p>清除方法</p>
<ul>
<li>额外标签法：在浮动元素末尾添加一个空的标签，例如 </li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"clear:both"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>优点：通俗易懂，书写方便<br>缺点：添加许多无意义的标签，结构化差。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>内容（例子）</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>额外标签法</td>
<td>在浮动元素末尾添加一个空的标签，例如：&lt;div style=”clear:both”&gt;&lt;/div&gt;</td>
<td>通俗易懂，书写方便</td>
<td>添加许多无意义的标签，结构化差</td>
</tr>
<tr>
<td>父级增加overflow属性方法</td>
<td>给父级元素增加overflow为hidden或auto或scroll都可以实现</td>
<td>代码简洁</td>
<td>内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素</td>
</tr>
<tr>
<td>使用after伪元素</td>
<td>.clearfix:after{content:”.”;display:block;height:0;visibility:hidden;clear:both}</td>
<td>符合闭合浮动思维，结构主义化明确</td>
<td>由于IE6-7不支持after,使用zoom:1触发 hasLayout</td>
</tr>
<tr>
<td>双伪元素</td>
<td>.clearfix:before,.clearfix:after{content:””,display:table}  .clearfix:after{clear:both} .clearfix{*zoom:1;}</td>
<td>代码更简洁</td>
<td>由于IE6-7不支持after,使用zoom:1触发 hasLayout</td>
</tr>
</tbody>
</table>
<h1 id="11-定位"><a href="#11-定位" class="headerlink" title="11. 定位"></a>11. 定位</h1><h2 id="11-1-元素的定位属性"><a href="#11-1-元素的定位属性" class="headerlink" title="11.1. 元素的定位属性"></a>11.1. 元素的定位属性</h2><p>元素的定位属性主要包括定位模式和边偏移两部分</p>
<h3 id="11-1-1-边偏移"><a href="#11-1-1-边偏移" class="headerlink" title="11.1.1. 边偏移"></a>11.1.1. 边偏移</h3><p>top,bottom,left,right</p>
<h3 id="11-1-2-定位模式"><a href="#11-1-2-定位模式" class="headerlink" title="11.1.2. 定位模式"></a>11.1.2. 定位模式</h3><p>语法: 选择器（postition属性值)</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
<th>是否脱标占有位置</th>
<th>是否可以使用边偏移</th>
<th>移动位置基准</th>
</tr>
</thead>
<tbody>
<tr>
<td>static</td>
<td>静态定位（默认定位方式）</td>
<td>不脱标</td>
<td>不可以</td>
<td>正常模式</td>
</tr>
<tr>
<td>relative</td>
<td>相对定位，相对于其原文档流位置进行定位</td>
<td>不脱标，占有位置</td>
<td>可以</td>
<td>相对自身位置移动</td>
</tr>
<tr>
<td>absolute</td>
<td>绝对定位，相对于其上一个已经定位的父元素进行定位</td>
<td>完全脱标，不占有位置</td>
<td>可以</td>
<td>相对于定位父级移动位置</td>
</tr>
<tr>
<td>fixed</td>
<td>固定定位，相对于浏览器窗口进行定位</td>
<td>完全脱标，不占有位置</td>
<td>可以</td>
<td>相对于浏览器移动位置</td>
</tr>
</tbody>
</table>
<h4 id="11-1-2-1-静态定位"><a href="#11-1-2-1-静态定位" class="headerlink" title="11.1.2.1. 静态定位"></a>11.1.2.1. 静态定位</h4><p>对于边偏移无效，通常用于清除定位的。</p>
<h4 id="11-1-2-2-相对定位"><a href="#11-1-2-2-相对定位" class="headerlink" title="11.1.2.2. 相对定位"></a>11.1.2.2. 相对定位</h4><ul>
<li>相对定位最重要的一点是，它可以通过边偏移移动位置，但是原来所占的位置，继续占有。</li>
<li>其次，每次移动的位置，是以自己的左上角为基点移动的。</li>
</ul>
<p>相对定位的盒子仍在标准流中，它后面的盒子仍以标准流来对待它</p>
<h4 id="11-1-2-3-绝对定位"><a href="#11-1-2-3-绝对定位" class="headerlink" title="11.1.2.3. 绝对定位"></a>11.1.2.3. 绝对定位</h4><p>绝对定位是完全脱标的，它不占有位置。</p>
<p>若所有父元素都没有定位，以浏览器为准对齐。</p>
<p>若父级有定位(绝对、固定或相对定位)，则以最近的有定位的父元素进行定位。</p>
<p>子绝父相：意思是子级是绝对定位的话，父级要用相对定位。</p>
<h4 id="11-1-2-4-固定定位"><a href="#11-1-2-4-固定定位" class="headerlink" title="11.1.2.4. 固定定位"></a>11.1.2.4. 固定定位</h4><ul>
<li>固定定位元素跟父亲没有任何关系</li>
<li>固定定位完全脱标，不占有位置，不随着滚动条滚动。</li>
</ul>
<h3 id="11-1-3-叠放次序-z-index"><a href="#11-1-3-叠放次序-z-index" class="headerlink" title="11.1.3. 叠放次序(z-index)"></a>11.1.3. 叠放次序(z-index)</h3><ul>
<li>z-index 的默认值是0，取值越大，定位元素层叠越居上</li>
<li>如果取值相同，则根据书写顺序，后来居上</li>
<li>后面数字一定不能加单位</li>
<li>只有相对定位、绝对定们、固定定位有此属性。</li>
</ul>
<h3 id="11-1-4-定位模式的转换"><a href="#11-1-4-定位模式的转换" class="headerlink" title="11.1.4. 定位模式的转换"></a>11.1.4. 定位模式的转换</h3><p>跟浮动一样，元素添加了绝对定位和固定定位之后，元素模式也会发生转换，都转换为行内块模式。</p>
<h3 id="11-1-5-元素的显示与隐藏"><a href="#11-1-5-元素的显示与隐藏" class="headerlink" title="11.1.5. 元素的显示与隐藏"></a>11.1.5. 元素的显示与隐藏</h3><p>隐藏：<br>display : none 隐藏之后不保留位置<br>visibility ：hidden 隐藏之后保留位置</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/21/CSS入门及提高/" data-id="cju85caij00048suql0juad3d" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-从零做一个前端开源项目学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/18/从零做一个前端开源项目学习笔记/" class="article-date">
  <time datetime="2018-07-18T11:28:43.000Z" itemprop="datePublished">2018-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/18/从零做一个前端开源项目学习笔记/">从零做一个前端开源项目学习笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="什么是开源"><a href="#什么是开源" class="headerlink" title="什么是开源"></a>什么是开源</h1><p>开源包括：</p>
<ul>
<li>源码</li>
<li>文档，如二次开发文档和用户使用文档</li>
<li>开发环境，告诉二次开发者如何搭建和运行代码</li>
<li>允许他人贡献代码：而不是仅仅给别人阅读代码的权限</li>
<li>问题：用户提问，维护者答复，问题共享</li>
<li>问题列表和升级计划：记录当前问题，以及何时解决、何时升级</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/18/从零做一个前端开源项目学习笔记/" data-id="cju85cakd000z8suqljysfpcv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="&#39;sql-SQL Server编程入门经典" class="article article-type-&#39;sql" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/09/SQL Server编程入门经典/" class="article-date">
  <time datetime="2018-07-09T01:09:25.000Z" itemprop="datePublished">2018-07-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/09/SQL Server编程入门经典/">SQL Server编程入门经典</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-RDBMS-基础：SQLServer-数据库的构成"><a href="#1-RDBMS-基础：SQLServer-数据库的构成" class="headerlink" title="1. RDBMS 基础：SQLServer 数据库的构成"></a>1. RDBMS 基础：SQLServer 数据库的构成</h1><h2 id="1-1-数据对象的概述"><a href="#1-1-数据对象的概述" class="headerlink" title="1.1. 数据对象的概述"></a>1.1. 数据对象的概述</h2><p>数据库对象：</p>
<ul>
<li>数据库本身</li>
<li>事务日志</li>
<li>表</li>
<li>索引</li>
<li>文件组</li>
<li>数据库关系图</li>
<li>视图</li>
<li>存储过程</li>
<li>用户自定义函数</li>
<li>序列</li>
<li>用户</li>
<li>角色</li>
<li>程序集</li>
<li>报表</li>
<li>全文目录</li>
<li>用户自定义数据类型</li>
</ul>
<h3 id="1-1-1-数据库对象"><a href="#1-1-1-数据库对象" class="headerlink" title="1.1.1. 数据库对象"></a>1.1.1. 数据库对象</h3><p>存储过程和视图是对存储在数据库表中的数据的特定分组</p>
<p>SQL Server 第一次启动时至少包括4个系统数据库</p>
<ul>
<li>master：系统表用于系统的总体控件</li>
<li>model：是指可以基于该模型得一个副本</li>
<li>msdb：SQL Agent 进程存储任意系统任务的地方</li>
<li>tempdb：是服务器的主要工作地方之一。在执行一个复杂或者大型的查询操作时，SQL Server可能需要创建一些中间表来完成该操作。每次启动SQLServer,tempdb数据库是系统中唯一完全重建的数据库。</li>
</ul>
<h3 id="1-1-2-事务日志"><a href="#1-1-2-事务日志" class="headerlink" title="1.1.2. 事务日志"></a>1.1.2. 事务日志</h3><p>实际上，任意数据库的更改起初不进入数据库本身，而是不断地被写入到事务日志。<br>日志是数据进入磁盘上的最先位置，且稍后会被传播到实际的数据库。需要数据库文件和事务日志一起完成数据库功能。</p>
<h3 id="1-1-3-最基本的数据库对象：表"><a href="#1-1-3-最基本的数据库对象：表" class="headerlink" title="1.1.3. 最基本的数据库对象：表"></a>1.1.3. 最基本的数据库对象：表</h3><ol>
<li>索引</li>
</ol>
<p>索引分两类：</p>
<ul>
<li>群集索引：每个表只能有一个群集索引，如果为百科全书做索引，则群集索引是书的页码</li>
<li>非群集索引：每个表可以有多个非群集索引。</li>
</ul>
<p>注意：具有索引的视图在有非群集索引之前必须有一个群集索引</p>
<ol start="2">
<li>触发器</li>
</ol>
<p>触发器有多种用途，但主要用于输入时复制数据或在更新时检查数据，确保数据满足相应条件。</p>
<ol start="3">
<li>约束</li>
</ol>
<h3 id="1-1-4-文件组"><a href="#1-1-4-文件组" class="headerlink" title="1.1.4. 文件组"></a>1.1.4. 文件组</h3><h3 id="1-1-5-数据库关系图"><a href="#1-1-5-数据库关系图" class="headerlink" title="1.1.5. 数据库关系图"></a>1.1.5. 数据库关系图</h3><h3 id="1-1-6-视图"><a href="#1-1-6-视图" class="headerlink" title="1.1.6. 视图"></a>1.1.6. 视图</h3><p>视图仅仅是表中所存储数据的一个预先计划的映射和表示。视图以查询的形式存储在数据库中。</p>
<p>视图的主要目的是控制视图用户查看的数据。</p>
<p>索引视图除了可以创建索引外，其它都与视图相同，其对使用性能的影响如下：</p>
<ul>
<li>对于引用多个表的视图来说，索引视图的可读性更好，因为它预告构建了表之间的连接。</li>
<li>由于预先计算好视图中执行的聚合(aggregation)，并将其作为索引的一部分存储，因此聚合只要执行一次（在插入或更新时），然后就可从索引信息中直接读取它。</li>
<li>由于视图上的索引必须及时更新，因此插入和删除索引需要更多的系统开销，如果更新影响到索引的键列或群集键，则更新也需要更多的系统开销。</li>
</ul>
<h3 id="1-1-7-存储过程"><a href="#1-1-7-存储过程" class="headerlink" title="1.1.7. 存储过程"></a>1.1.7. 存储过程</h3><p>存储过程优点：</p>
<ul>
<li>不使用长字符中文本而使用短字符串存储过程名，可减少运行存储过程中的代码所需要的网络通信流量。</li>
<li>预先优化和预编译，节省每次运行存储过程的时间。</li>
<li>通常考虑安全原因，或仅仅隐藏数据库的复杂性，将过程封装。</li>
<li>可从其它存储过程调用，使得它们在某些限定意义上重用。</li>
</ul>
<h3 id="1-1-8-用户自定义函数"><a href="#1-1-8-用户自定义函数" class="headerlink" title="1.1.8. 用户自定义函数"></a>1.1.8. 用户自定义函数</h3><p>用户自定义函数（UDF）与存储过程十分相似，不同之处有如下几点：</p>
<ul>
<li>返回值的数据类型包括大部分 SQLServer 数据类型。不包括的返回值数据类型有：text,ntext,image,cursor,timestamp</li>
<li>没有“副作用”。基本上用户自定义函数不能超出函数的作用范围。</li>
</ul>
<p>传送到函数中的所有变量都是按值传递的，但可以返回一种特殊的数据类型–表</p>
<h3 id="1-1-9-序列"><a href="#1-1-9-序列" class="headerlink" title="1.1.9. 序列"></a>1.1.9. 序列</h3><p>序列的作用是提供任意数量的进程都可以访问的序号源，同时保证任意两个进程不会同时获取相同的下一个值。因为序列是单独存在的对象(没有绑定到任何表),所以它可以有多种用途。</p>
<h3 id="1-1-10-用户和角色"><a href="#1-1-10-用户和角色" class="headerlink" title="1.1.10. 用户和角色"></a>1.1.10. 用户和角色</h3><h3 id="1-1-11-规则"><a href="#1-1-11-规则" class="headerlink" title="1.1.11. 规则"></a>1.1.11. 规则</h3><h3 id="1-1-12-默认值"><a href="#1-1-12-默认值" class="headerlink" title="1.1.12. 默认值"></a>1.1.12. 默认值</h3><p>SQL Server 中有两种类型的默认值，包括对象本身的默认值，以及描述表中特定列的元数据的默认值。</p>
<h3 id="1-1-13-用户自定义数据类型"><a href="#1-1-13-用户自定义数据类型" class="headerlink" title="1.1.13. 用户自定义数据类型"></a>1.1.13. 用户自定义数据类型</h3><h3 id="1-1-14-全文目录"><a href="#1-1-14-全文目录" class="headerlink" title="1.1.14. 全文目录"></a>1.1.14. 全文目录</h3><h2 id="1-2-SQL-Server-数据类型"><a href="#1-2-SQL-Server-数据类型" class="headerlink" title="1.2. SQL Server 数据类型"></a>1.2. SQL Server 数据类型</h2><p><img src="/2018/07/09/SQL Server编程入门经典/SQL_Server编程入门经典/数据类型1.png" alt="数据类型1"><br><img src="/2018/07/09/SQL Server编程入门经典/SQL_Server编程入门经典/数据类型2.png" alt="数据类型2"></p>
<h1 id="2-连接"><a href="#2-连接" class="headerlink" title="2. 连接"></a>2. 连接</h1><p>数据库规范化是指将数据从更大的表分割成几个较小的表，目的是消除重复的数据、节省空间、提高数据库性能，并增加数据完整性。</p>
<h2 id="2-1-内部连接"><a href="#2-1-内部连接" class="headerlink" title="2.1. 内部连接"></a>2.1. 内部连接</h2><p>INNER JOIN:内部连接是一个排他的连接，即排除在两表————第一个指定的表（即左表）和第二个指定表（即右表）————中没有匹配的所有记录。</p>
<h3 id="2-1-1-处理更复杂的外部连接"><a href="#2-1-1-处理更复杂的外部连接" class="headerlink" title="2.1.1. 处理更复杂的外部连接"></a>2.1.1. 处理更复杂的外部连接</h3><p>在所有的查询的语句中，JOIN 左侧或之前的所有表只作为一个表，不论查询语句是要包含或排除表中的数据。同样，所有查询语句中 JOIN 右侧或之后的所有表只作为一个表。</p>
<p>通常，应首先使用内部连接，然后尽量少地使用外部连接，这样可以减少代码中的错误。</p>
<h2 id="2-2-联合"><a href="#2-2-联合" class="headerlink" title="2.2. 联合"></a>2.2. 联合</h2><p>JOIN 将信息水平连接（添加更多列），而 UNION 将数据垂直连接（添加更多行）。</p>
<h1 id="3-创建和修改数据表"><a href="#3-创建和修改数据表" class="headerlink" title="3. 创建和修改数据表"></a>3. 创建和修改数据表</h1><h2 id="3-1-SQL-SERVER-中的对象名"><a href="#3-1-SQL-SERVER-中的对象名" class="headerlink" title="3.1. SQL SERVER 中的对象名"></a>3.1. SQL SERVER 中的对象名</h2><p>有4层命名约定</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ServerName.[DatabaseName.[SchemaName.]]]ObjectName</span><br></pre></td></tr></table></figure>
<h1 id="4-刍和约束"><a href="#4-刍和约束" class="headerlink" title="4. 刍和约束"></a>4. 刍和约束</h1><p>确保数据完整性不是使用数据库的程序的责任，而是数据库本身的责任。</p>
<p>有3种不同类型的约束</p>
<ul>
<li>实体约束</li>
<li>域约束</li>
<li>参照完整笥约束</li>
</ul>
<p>约束的方法</p>
<ul>
<li>主键约束</li>
<li>外键约束</li>
<li>唯一约束(也称替换键)</li>
<li>CHECK约束</li>
<li>DEFAULT约束</li>
<li>规则</li>
<li>默认值(和DEFAULT约束类似)</li>
</ul>
<h2 id="4-1-约束的类型"><a href="#4-1-约束的类型" class="headerlink" title="4.1. 约束的类型"></a>4.1. 约束的类型</h2><h3 id="4-1-1-域约束"><a href="#4-1-1-域约束" class="headerlink" title="4.1.1. 域约束"></a>4.1.1. 域约束</h3><p>域约束处理一个或多个列</p>
<h2 id="4-2-键约束"><a href="#4-2-键约束" class="headerlink" title="4.2. 键约束"></a>4.2. 键约束</h2><p>主键、外键、替换键和倒置健</p>
<h1 id="5-更复杂的查询"><a href="#5-更复杂的查询" class="headerlink" title="5. 更复杂的查询"></a>5. 更复杂的查询</h1><h2 id="5-1-子查询的概念"><a href="#5-1-子查询的概念" class="headerlink" title="5.1. 子查询的概念"></a>5.1. 子查询的概念</h2><p>子查询通常用于满足下列某个需求</p>
<ul>
<li>将一个查询分解为一系列的逻辑步骤</li>
<li>提供一个列表作为 WHERE 子句和 [IN|EXIST|ANY|ALL]的目标</li>
<li>为父查询中的每个记录提供一个查询表</li>
</ul>
<h2 id="5-2-关联子查询"><a href="#5-2-关联子查询" class="headerlink" title="5.2. 关联子查询"></a>5.2. 关联子查询</h2><p>关联子查询与嵌套子查询的不同之处在于：信息传递是双向的，而不是单向的。在嵌套子查询中，内部查询只处理一次，然后将信息传递到外部查询，而外部查询也只执行一次————提供和您自己可能输入的完全相同的值或列表。</p>
<p>关联子查询处理过程</p>
<ul>
<li>外部查询获取一个记录，然后将该记录传递到内部查询</li>
<li>内部查询根据传递的值进行查询</li>
<li>内部查询将结果值传递回外部查询，而外部查询利用这些值完成处理过程。</li>
</ul>
<h1 id="6-存储过程"><a href="#6-存储过程" class="headerlink" title="6. 存储过程"></a>6. 存储过程</h1><h1 id="7-数据库查询优化技巧"><a href="#7-数据库查询优化技巧" class="headerlink" title="7. 数据库查询优化技巧"></a>7. 数据库查询优化技巧</h1><h2 id="7-1-比较运算符能用-“-”就不用“-lt-gt-”"><a href="#7-1-比较运算符能用-“-”就不用“-lt-gt-”" class="headerlink" title="7.1. 比较运算符能用 “=”就不用“&lt;&gt;”"></a>7.1. 比较运算符能用 “=”就不用“&lt;&gt;”</h2><p>“=”增加了索引的使用几率。</p>
<h2 id="7-2-明知只有一条查询结果，那请使用-“LIMIT-1”"><a href="#7-2-明知只有一条查询结果，那请使用-“LIMIT-1”" class="headerlink" title="7.2. 明知只有一条查询结果，那请使用 “LIMIT 1”"></a>7.2. 明知只有一条查询结果，那请使用 “LIMIT 1”</h2><p>“LIMIT 1”可以避免全表扫描，找到对应结果就不会再继续扫描了。</p>
<h2 id="7-3-为列选择合适的数据类型"><a href="#7-3-为列选择合适的数据类型" class="headerlink" title="7.3. 为列选择合适的数据类型"></a>7.3. 为列选择合适的数据类型</h2><p>能用TINYINT就不用SMALLINT，能用SMALLINT就不用INT，道理你懂的，磁盘和内存消耗越小越好嘛。</p>
<h2 id="7-4-将大的DELETE，UPDATE-or-INSERT-查询变成多个小查询"><a href="#7-4-将大的DELETE，UPDATE-or-INSERT-查询变成多个小查询" class="headerlink" title="7.4. 将大的DELETE，UPDATE or INSERT 查询变成多个小查询"></a>7.4. 将大的DELETE，UPDATE or INSERT 查询变成多个小查询</h2><p>能写一个几十行、几百行的SQL语句是不是显得逼格很高?然而，为了达到更好的性能以及更好的数据控制，你可以将他们变成多个小查询。</p>
<p>查询数据库，你还在 Select * 吗？</p>
<h2 id="7-5-使用UNION-ALL-代替-UNION，如果结果集允许重复的话"><a href="#7-5-使用UNION-ALL-代替-UNION，如果结果集允许重复的话" class="headerlink" title="7.5. 使用UNION ALL 代替 UNION，如果结果集允许重复的话"></a>7.5. 使用UNION ALL 代替 UNION，如果结果集允许重复的话</h2><p>因为 UNION ALL 不去重，效率高于 UNION。</p>
<h2 id="7-6-为获得相同结果集的多次执行，请保持SQL语句前后一致"><a href="#7-6-为获得相同结果集的多次执行，请保持SQL语句前后一致" class="headerlink" title="7.6. 为获得相同结果集的多次执行，请保持SQL语句前后一致"></a>7.6. 为获得相同结果集的多次执行，请保持SQL语句前后一致</h2><p>这样做的目的是为了充分利用查询缓冲。</p>
<p>比如根据地域和产品id查询产品价格，第一次使用了：</p>
<p>查询数据库，你还在 Select * 吗？<br>那么第二次同样的查询，请保持以上语句的一致性，比如不要将where语句里面的id和region位置调换顺序。</p>
<h2 id="7-7-尽量避免使用-“SELECT-”"><a href="#7-7-尽量避免使用-“SELECT-”" class="headerlink" title="7.7. 尽量避免使用 “SELECT *”"></a>7.7. 尽量避免使用 “SELECT *”</h2><p>如果不查询表中所有的列，尽量避免使用 SELECT *，因为它会进行全表扫描，不能有效利用索引，增大了数据库服务器的负担，以及它与应用程序客户端之间的网络IO开销。</p>
<p>查询数据库，你还在 Select * 吗？</p>
<h2 id="7-8-WHERE-子句里面的列尽量被索引"><a href="#7-8-WHERE-子句里面的列尽量被索引" class="headerlink" title="7.8. WHERE 子句里面的列尽量被索引"></a>7.8. WHERE 子句里面的列尽量被索引</h2><p>只是“尽量”哦，并不是说所有的列。因地制宜，根据实际情况进行调整，因为有时索引太多也会降低性能。</p>
<h2 id="7-9-JOIN-子句里面的列尽量被索引"><a href="#7-9-JOIN-子句里面的列尽量被索引" class="headerlink" title="7.9. JOIN 子句里面的列尽量被索引"></a>7.9. JOIN 子句里面的列尽量被索引</h2><p>同样只是“尽量”哦，并不是说所有的列。</p>
<h2 id="7-10-ORDER-BY-的列尽量被索引"><a href="#7-10-ORDER-BY-的列尽量被索引" class="headerlink" title="7.10. ORDER BY 的列尽量被索引"></a>7.10. ORDER BY 的列尽量被索引</h2><p>ORDER BY的列如果被索引，性能也会更好。</p>
<h2 id="7-11-使用-LIMIT-实现分页逻辑"><a href="#7-11-使用-LIMIT-实现分页逻辑" class="headerlink" title="7.11. 使用 LIMIT 实现分页逻辑"></a>7.11. 使用 LIMIT 实现分页逻辑</h2><p>不仅提高了性能，同时减少了不必要的数据库和应用间的网络传输。</p>
<h2 id="7-12-使用-EXPLAIN-关键字去查看执行计划"><a href="#7-12-使用-EXPLAIN-关键字去查看执行计划" class="headerlink" title="7.12. 使用 EXPLAIN 关键字去查看执行计划"></a>7.12. 使用 EXPLAIN 关键字去查看执行计划</h2><p>EXPLAIN 可以检查索引使用情况以及扫描的行。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/09/SQL Server编程入门经典/" data-id="cju85caje000l8suqtcr5b11o" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CLR via C#学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/05/CLR via C#学习笔记/" class="article-date">
  <time datetime="2018-07-05T00:49:53.470Z" itemprop="datePublished">2018-07-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="什么是CLR"><a href="#什么是CLR" class="headerlink" title="什么是CLR"></a>什么是CLR</h2><p>是一种可由多种编程语言共同使用的运行时。</p>
<h2 id="CLR的核心功能"><a href="#CLR的核心功能" class="headerlink" title="CLR的核心功能"></a>CLR的核心功能</h2><p>内存管理、程序集加载、安全性、异常处理和线程同步</p>
<h2 id="程序集"><a href="#程序集" class="headerlink" title="程序集"></a>程序集</h2><p>程序集是一个或多个模块\资源文件的逻辑性分组<br>程序集是重用、安全性以及版本控制的最小单元</p>
<h2 id="IL的最大优势"><a href="#IL的最大优势" class="headerlink" title="IL的最大优势"></a>IL的最大优势</h2><p>IL的最大优势并不在于它对底层CPU的抽象。而在于其提供的应用程序的健壮性和安全性。</p>
<h2 id="unsafe关键字"><a href="#unsafe关键字" class="headerlink" title="unsafe关键字"></a>unsafe关键字</h2><p>C#编译器要求包含不安全代码的所有方法都用unsafe关键字标记。</p>
<h1 id="本地代码生成器：NGen-exe"><a href="#本地代码生成器：NGen-exe" class="headerlink" title="本地代码生成器：NGen.exe"></a>本地代码生成器：NGen.exe</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/05/CLR via C#学习笔记/" data-id="cju85caig00038suqs4hnr3gi" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ModelUI for WPF" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/08/ModelUI for WPF/" class="article-date">
  <time datetime="2018-03-08T00:53:36.000Z" itemprop="datePublished">2018-03-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/08/ModelUI for WPF/">ModelUI for WPF</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="使用ModelUI"><a href="#使用ModelUI" class="headerlink" title="使用ModelUI"></a>使用ModelUI</h1><h2 id="首先获取相关dll"><a href="#首先获取相关dll" class="headerlink" title="首先获取相关dll"></a>首先获取相关dll</h2><p>[github地址]：<a href="https://github.com/firstfloorsoftware/mui" target="_blank" rel="noopener">https://github.com/firstfloorsoftware/mui</a></p>
<h2 id="在项目中添加引用"><a href="#在项目中添加引用" class="headerlink" title="在项目中添加引用"></a>在项目中添加引用</h2><p>在目录FirstFloor.ModernUI\FirstFloor.ModernUI\bin\Debug下找到FirstFloor.ModernUI.dll,添加到你所需要的wpf项目中</p>
<p>在项目的App.xaml中添加如下代码</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Application</span> <span class="attr">x:Class</span>=<span class="string">"SuperRecite.App"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">xmlns</span>=<span class="string">"http://schemas.microsoft.com/winfx/2006/xaml/presentation"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">xmlns:x</span>=<span class="string">"http://schemas.microsoft.com/winfx/2006/xaml"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">xmlns:local</span>=<span class="string">"clr-namespace:SuperRecite"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">StartupUri</span>=<span class="string">"MainWindow.xaml"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Application.Resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ResourceDictionary</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ResourceDictionary.MergedDictionaries</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ResourceDictionary</span> <span class="attr">Source</span>=<span class="string">"/FirstFloor.ModernUI;component/Assets/ModernUI.xaml"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ResourceDictionary</span> <span class="attr">Source</span>=<span class="string">"/FirstFloor.ModernUI;component/Assets/ModernUI.Light.xaml"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ResourceDictionary.MergedDictionaries</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ResourceDictionary</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Application.Resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Application</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在项目的主页面中添加引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlns:mui=&quot;http://firstfloorsoftware.com/ModernUI&quot;</span><br></pre></td></tr></table></figure>
<p> 主窗体后台改变继承的基类</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public partial class MainWindow : ModernWindow</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/08/ModelUI for WPF/" data-id="cju85caji000o8suqyh3te4rf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-设计模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/04/设计模式/" class="article-date">
  <time datetime="2018-03-04T15:26:58.000Z" itemprop="datePublished">2018-03-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/04/设计模式/">设计模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="C-面向对象设计模式纵横谈"><a href="#C-面向对象设计模式纵横谈" class="headerlink" title="C# 面向对象设计模式纵横谈"></a>C# 面向对象设计模式纵横谈</h1><h2 id="设计模式与面向对象"><a href="#设计模式与面向对象" class="headerlink" title="设计模式与面向对象"></a>设计模式与面向对象</h2><p>面向对象设计模式解决的是“类与相互通信的对象之间的组织关系，包括它们的角色、职责、协作方式几个方面。</p>
<p>所谓好的面向对象设计就是那些可以满足“应对变化，提高复用”的设计。</p>
<p>源代码即设计。</p>
<h2 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/04/设计模式/" data-id="cju85cal5001a8suq1o8p4d7s" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-T4模板" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/01/T4模板/" class="article-date">
  <time datetime="2018-03-01T09:19:55.000Z" itemprop="datePublished">2018-03-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/01/T4模板/">T4模板</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-T4基本语法"><a href="#1-T4基本语法" class="headerlink" title="1. T4基本语法"></a>1. T4基本语法</h1><p>T4语法主要包括三类：1指令 2文本块 3指令块</p>
<h2 id="1-1-指令"><a href="#1-1-指令" class="headerlink" title="1.1. 指令"></a>1.1. 指令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;# 标准控制块 #&gt; 可以包含语句</span><br><span class="line">&lt;#= 表达式控制块 #&gt; 可以包含表达式</span><br><span class="line">&lt;#+ 类特征控制块 #&gt; 可以包含方法、属性和字段，就像一个类的内部</span><br></pre></td></tr></table></figure>
<p>指令主要包括template, output, assembly, import, include等类型<br>在这里是指令T4语法以&lt;#开头结尾</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;#@ 指令 属性=“值”#&gt;</span><br></pre></td></tr></table></figure>
<h3 id="1-1-1-模板指令"><a href="#1-1-1-模板指令" class="headerlink" title="1.1.1. 模板指令"></a>1.1.1. 模板指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;#@ template debug=&quot;false&quot; hostspecific=&quot;false&quot; language=&quot;C#&quot; #&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>language: 输出语言.</li>
<li>debug: 是否启用调试.</li>
<li>hostspecific:有效值true、false，默认为false。如果将此特性的值设置为 true，则会将名为 Host 的属性添加到由文本模板生成的类中。 该属性是对转换引擎的宿主的引用，并声明为Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost。</li>
<li>inheirits:可以指定模板的程序代码可以继承自另一个类</li>
</ul>
<h2 id="1-2-输出指令"><a href="#1-2-输出指令" class="headerlink" title="1.2. 输出指令"></a>1.2. 输出指令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;#@ output extension=&quot;.cs&quot; #&gt;</span><br></pre></td></tr></table></figure>
<p>生成文件的后缀名.</p>
<h2 id="1-3-程序集指令"><a href="#1-3-程序集指令" class="headerlink" title="1.3. 程序集指令"></a>1.3. 程序集指令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;#@ assembly name=&apos;System&apos; #&gt;</span><br></pre></td></tr></table></figure>
<p>告诉T4引擎编译运行时引用System程序集.</p>
<ul>
<li>$(SolutionDir):当前项目所在解决方案目录</li>
<li>$(ProjectDir):当前项目所在目录</li>
<li>$(TargetPath):当前项目编译输出文件绝对路径</li>
<li>$(TargetDir):当前项目编译输出目录，即web项目的Bin目录，控制台、类库项目bin目录下的debug或release目录(取决于当前的编译模式)</li>
</ul>
<p>举个例子：比如我们在D盘根目录建立了一个控制台项目MyTest，解决方案目录为D:\Feng，项目目录为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">D:\Feng\MyTest，那么此时在Debug编译模式下</span><br><span class="line">$(SolutionDir)的值为D:\Feng</span><br><span class="line">$(ProjectDir)的值为D:\Feng\MyTest</span><br><span class="line">$(TargetPath)值为D:\Feng\MyTest\bin\Debug\MyTest.exe</span><br><span class="line">$(TargetDir)值为D:\Feng\MyTest\bin\Debug\</span><br></pre></td></tr></table></figure>
<h3 id="1-3-1-导入指令"><a href="#1-3-1-导入指令" class="headerlink" title="1.3.1. 导入指令"></a>1.3.1. 导入指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;#@ import namespace=&quot;System.Data&quot; #&gt;</span><br></pre></td></tr></table></figure>
<p>告诉T4引擎编译运行时引用某个名称空间。在 Visual Studio T4 文本模板的代码块中，import 指令允许您在不提供完全限定名称的情况下引用另一个命名空间中的元素。 它等效于 C# 中的 using 或 Visual Basic 中的 imports。默认已经导入了System命名空间的引用。</p>
<h3 id="1-3-2-包含指令"><a href="#1-3-2-包含指令" class="headerlink" title="1.3.2. 包含指令"></a>1.3.2. 包含指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;#@ include file=&quot;Base.ttinclude&quot;#&gt;</span><br></pre></td></tr></table></figure>
<p>运行时引用某个文件，类似于JS的引用。</p>
<p>包含指令可以提高代码复用率，比如我们可以将一些常用的程序集、命名空间引用放到一个文件里，使用时仅需要引用下即可，省去了每次都要重新引用一遍的烦恼，如我们建立Reference.ttinclude文件，里面包含了我们平时常用的程序集引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;#@ assembly name=&quot;System.Core.dll&quot; #&gt;</span><br><span class="line">&lt;#@ assembly name=&quot;System.Data.dll&quot; #&gt;</span><br><span class="line">&lt;#@ assembly name=&quot;System.Data.DataSetExtensions.dll&quot; #&gt;</span><br><span class="line">&lt;#@ assembly name=&quot;System.Xml.dll&quot; #&gt;</span><br><span class="line">&lt;#@ import namespace=&quot;System&quot; #&gt;</span><br><span class="line">&lt;#@ import namespace=&quot;System.Xml&quot; #&gt;</span><br><span class="line">&lt;#@ import namespace=&quot;System.Linq&quot; #&gt;</span><br><span class="line">&lt;#@ import namespace=&quot;System.Data&quot; #&gt;</span><br><span class="line">&lt;#@ import namespace=&quot;System.Data.SqlClient&quot; #&gt;</span><br><span class="line">&lt;#@ import namespace=&quot;System.Collections.Generic&quot; #&gt;</span><br><span class="line">&lt;#@ import namespace=&quot;System.IO&quot; #&gt;</span><br></pre></td></tr></table></figure>
<p>使用时只需要使用包含指令引用下即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;#@ include file=&quot;$(ProjectDir)Reference.ttinclude&quot;  #&gt;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-3-参数指令"><a href="#1-3-3-参数指令" class="headerlink" title="1.3.3. 参数指令"></a>1.3.3. 参数指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;#@ parameter type=&quot;string&quot; name=&quot;ParameterName&quot; #&gt;</span><br></pre></td></tr></table></figure>
<p>顾名思义就是定义一个参数在其他的地方使用。</p>
<h2 id="1-4-文本块"><a href="#1-4-文本块" class="headerlink" title="1.4. 文本块"></a>1.4. 文本块</h2><p>文本块直接向输出文件插入文本。</p>
<h2 id="1-5-指令块"><a href="#1-5-指令块" class="headerlink" title="1.5. 指令块"></a>1.5. 指令块</h2><p>主要用于控制文本的输出。在控制块中可以写任意的C#代码</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/01/T4模板/" data-id="cju85cajt000s8suqunnibwtd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习笔记/">学习笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Access数据库" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/01/Access数据库/" class="article-date">
  <time datetime="2018-03-01T05:28:22.000Z" itemprop="datePublished">2018-03-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/01/Access数据库/">Access总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Access字段属性"><a href="#Access字段属性" class="headerlink" title="Access字段属性"></a>Access字段属性</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OleDbCommand command = new OleDbCommand(sql, Connection);</span><br><span class="line">OleDbDataReader reader = command.ExecuteReader();</span><br><span class="line">DataTable dt = new DataTable();</span><br><span class="line">dt = reader.GetSchemaTable();</span><br></pre></td></tr></table></figure>
<p>下表是dt所包含的内容<br>| dt列名     | OLE DB 列 ID  | 说明                                                     |<br>| ———- | ————- | ——————————————————– |<br>| ColumnName | DBCOLUMN_NAME | 列的名称；它可能不唯一。如果无法确定该名称，则返回空值。此名称始终反映最近对当前视图或命令文本中的列进行的重命名|<br>|ColumnOrdinal|DBCOLUMN_NUMBER|列的序号。它对于行的书签列（如果有的话）为零。其他列从一开始编号。该列不能包含空值|<br>|ColumnSize|DBCOLUMN_COLUMNSIZE|列中值的最大可能长度。对于采用固定长度数据类型的列，它是该数据类型的大小|<br>|NumericPrecision|DBCOLUMN_PRECISION|如果 DbType 是数值数据类型，则它是列的最大精度。数据类型为 DBTYPE_DECIMAL 或 DBTYPE_NUMERIC 的列的精度取决于该列的定义。如果 DbType 不是数值数据类型，则它为空值|<br>|NumericScale|DBCOLUMN_SCALE|如果 DbType 是 DBTYPE_DECIMAL 或 DBTYPE_NUMERIC，则它是小数点右侧的位数。否则，它为空值|<br>|DataType|无|映射到列的 .NET Framework 类型。<br>|ProviderType|DBCOLUMN_TYPE|列的数据类型的指示符。如果不同行的列数据类型不同，则它必须为 DBTYPE_VARIANT。该列不能包含空值。<br>|IsLong|DBCOLUMNFLAGS_ISLONG|如果列中有包含非常长的数据的二进制长对象 (BLOB)，则提供程序设置 DBCOLUMNFLAGS_ISLONG。非常长的数据的定义针对于提供程序。此标志的设置对应于该数据类型的 PROVIDER_TYPES 行集合中 IS_LONG 列的值。<br>|AllowDBNull|DBCOLUMNFLAGS_ISNULLABLE|如果使用者可将列设置为空值，或者提供程序无法确定使用者是否可将列设置为空值，提供程序就会设置DBCOLUMNFLAGS_ISNULLABLE。即使列无法设置为空值，|它仍可能包含空值。<br>|IsReadOnly|DBCOLUMNFLAGS_WRITE|如果不能修改该列，则为 true；否则为 false。如果提供程序已经设置了 DBCOLUMNFLAGS_WRITE 或DBCOLUMNFLAGS_WRITEUNKNOWN 标志，则认为该列是可写的。<br>|IsRowVersion|DBCOLUMNFLAGS_ISROWID|如果列包含不能写入的持久性行标识符，并且该标识符除了标识行以外没有其他有意义的值，则提供程序设置 DBCOLUMNFLAGS_ISROWID。<br>|IsUnique|DBCOLUMN_ISUNIQUE|VARIANT_TRUE：在该列中，基表（返回到 BaseTableName 中的表）中的任意两行的值都不能相同。如果该列本身表示一个键，或者有一个只应用于该列的 UNIQUE 类型的约束，则 IsUnique保证为 VARIANT_TRUE。VARIANT_FALSE：该列包含基表中的重复值。此列的默认值为 VARIANT_FALSE。<br>|IsKey|DBCOLUMN_KEYCOLUMN|VARIANT_TRUE：该列属于行集中的列集，结合使用列集中的列可唯一标识行。IsKey 设置为 VARIANT_TRUE 的列集必须唯一标识行集中的行。不要求此列集是最小列集。这组列可以从基表主键、唯一约束或唯一索引生成。VARIANT_FALSE：不要求该列唯一标识行。<br>|IsAutoIncrement|DBCOLUMN_ISAUTOINCREMENT|VARIANT_TRUE：该列以固定的增量向新行赋值。VARIANT_FALSE：该列不会以固定增量为新行赋值。此列的默认值为 VARIANT_FALSE。<br>|BaseSchemaName|DBCOLUMN_BASESCHEMANAME|包含列的数据存储区中的架构的名称。如果无法确定基架构名称，则为空值。该列的默认值为空值。<br>|BaseCatalogName|DBCOLUMN_BASECATALOGNAME|包含列的数据存储区中的目录的名称。如果无法确定基目录名称，则为空值。该列的默认值为空值。<br>|BaseTableName|DBCOLUMN_BASETABLENAME|包含列的数据存储区中的表或视图的名称。如果无法确定基表名称，则为空值。该列的默认值为空值。<br>|BaseColumnName|DBCOLUMN_BASECOLUMNNAME|数据存储区中列的名称。如果使用别名，它可能不同于在ColumnName 列中返回的列名称。如果无法确定基列名称，或者如果行集合列从数据存储区中的列导出但不等于该列，则为空值。该列的默认值为空值。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/01/Access数据库/" data-id="cju85caj1000c8suqq5xipqm9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-千万别说你懂买房" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/28/千万别说你懂买房/" class="article-date">
  <time datetime="2018-02-28T14:18:35.000Z" itemprop="datePublished">2018-02-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/28/千万别说你懂买房/">千万别说你懂买房</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="千万别说你懂买房-徐斌"><a href="#千万别说你懂买房-徐斌" class="headerlink" title="千万别说你懂买房 -徐斌"></a>千万别说你懂买房 -徐斌</h1><h2 id="买房准备之资格认定"><a href="#买房准备之资格认定" class="headerlink" title="买房准备之资格认定"></a>买房准备之资格认定</h2><p>买房的第一步，是要有购买资格。<br>认房，就是看包括你、你的丈夫（妻子）、未成年子女在内的家庭，在打算买房的这个城市里，有没有房屋登记系统或者合同网上备案系统里面的记录。所以在“认房”的情况下，在其他城市有房子是不会影响购房资格的。<br>认贷，就是看你在银行有没有贷款买房的记录。<br>房子的共有权人无论拥有多少份额，都视为有一套房，比如你和其他6个兄弟共同继承了一套房子，也算你有一套房。<br>•连续缴纳社保“或”个税，满足一项就可以。<br>•共有权人之间转让共有住房产权份额的，不需要购房资格核验。<br>赠与住房时，受赠方须具有购房资格才能接受赠与。<br>•继承住房时，继承人不需要进行购房资格核验。</p>
<h2 id="买房准备之资金"><a href="#买房准备之资金" class="headerlink" title="买房准备之资金"></a>买房准备之资金</h2><p>定金是买房交的第一笔钱，是购房人支付给业主的。<br>法律规定定金的数额是有上限的，上限是总房款的20%。<br>不管是贷款买房还是全款买房，<br>过户前购房人都不用支付全部房款。首套房一般是首付30%，付50%、80%也都没问题。<br>银行贷款的还款方式有两种。<br>一种是等额本息还款：把住房抵押贷款的本金总额与利息总额相加，然后平均分摊到还款期限的每个月中。还款人每个月还给银行固定金额，但每月还款额中的本金比重逐月递增，利息比重逐月递减。<br>另一种是等额本金还款：将本金<br>分摊到每个月内，同时付清上一交易日至本次还款日之间的利息。这种还款方式与等额本息还款相比，总的利息支出较低，但是前期支付的本金和利息较多，还款负担逐月递减。<br>房屋租赁的中介费是半个月到一个月的房租；房屋买卖的中介费是总房款的2.5%，最高不超过3%。<br>二手房交易的税费，主要有三种：个人所得税、契税、增值税（营业税）。<br>除了这三种，还有城建税、印花税、土地增值税、教育费附加、综合地价款、土地出让金、土地收<br>益。其中，法律规定由购房人承担的只有契税、印花税和土地出让金。三个比较大的税种都有各自的免税政策。<br>二手房交易税费是必须在过户之前缴纳的。购房人根据网签合同的价格到地税缴税之后才能办理过户手续（地税缴税和过户是在两个地方），通常在过户当天（前一天）办理缴税。<br>契税通常是网签交易价格的1%—3%，<br>二手房交易环节也开始“营改增”。过去的营业税是<br>成交价的5.5%，增值税则是房屋增值部分——合同成交价和取得房屋的交易价格的价差的5%（具体征收标准见表4–3，表4–4）。<br>我们在买房的时候经常看到满五唯一、满二唯一、满五不唯一等描述，这其实是说这个房子是不是符合个人所得税、增值税的免税条件。<br>“满”，就是房产证下来了几年。“唯一”，就是业主只有这一套房子（一般是本省市内）。<br>增值税的免税条件就是满两年。<br>这个满几年是看房产证或契税完税凭证的时间，哪个早就按哪个算。如果中间重新办理过房产证——比如因为房主去世发生了继承、换发了新的产权证，就可能按照新的房产证重新计算时间。<br>个人所得税的免税政策原先是满五唯一，意思是房子要满五年，而且业主只有这一套房子，才能免税。所以满二免增值税，满五唯一免个人所得税。如果满二不满五，就算房子唯一也没有什么用。<br>个人所得税有两种计算方式，一种是合同成交价的1%（有的城市可能<br>比例不同），另外一种是交易差价的20%（如表4–5所示）。<br>实杨先生在签合同的时候加一句话就可以规避这个问题：过户时产生的税费由买方杨先生承担，但是以2万元为上限，超出部分由业主承担。</p>
<h2 id="选房三步走"><a href="#选房三步走" class="headerlink" title="选房三步走"></a>选房三步走</h2><p>选房的第一步就是明确房子的性质，决定哪些类型的房子可以考虑，哪些坚决不碰。<br>法律上对房子的分类很简单，只有商品房和存量房两种，商品房就是一手房，存量房就是二手房。商品房采用期房预售制，购房人从开发商手里买房，存量房是购房人从业主手里买房。<br>房产证上面其实也有一些关于土地权利的内容，比如土地性质是划拨（白给）还是出让（买来的）。买二手房的时候需要注意这一点，因为不是说你买了房子，这个房子的产权就重新往后推70年。只有当房子原来的土地性质是划拨时，你买房之后补缴土地出让金，土地性质变成出让，房子才会从0开始用70年。如果你买房的时候土地性质就是出让，土地的70年产权是不会重新计算的。所以如果业主已经住了69年（实际上北京还没有这么老的房子），你再住1年就到期了。<br>房改房因为土地性质一般都是划拨，<br>这种房子的性质并不体现在法律里，也不体现在房产证上，而是体现在一些政策中，<br>央产房过户的前提条件是组织同意这套房子“上市”，而同意的标志是这套房子在位于蓝岛大厦的央产房管理中心备案。只有“蓝岛”给备案了，央产房才可以上市。<br>。房改房的土地性质都是划拨，也就是说当时并没有出钱买这块地，而是国家基于政策无偿供应了土地。这个土地性质会写在房产证里。<br>房产证上写着划拨，那么假设这房子要过户给你，你就要补缴土地出让金<br>法律上并没有小产权这个说法，它指代的一般是集体土地上的房子。<br>我们国家的土地分为国有土地和集体土地两种性质：国有土地就是由国家所有；集体土地就是由村集体所有。<br>集体土地只能在本集体成员内部流转，不可对外出售。用通俗的话说就是，农民的土地上盖的房子，居民（外村人）不能买。不能买包括以下三层意思。<br>买了房子不能过户。•双方签的买卖合同一般被认为是无效的。•卖家打个官司就可以把房子要回去。<br>一旦小产权房“转正”，引起的房价暴跌风险也不是闹着玩儿的。对政府来说，村集体手里这些集体土地是政府的土地储备，一旦让它们自由进入市场，不仅会影响现在的政府规划，也会间接导致城市的房价受到大量低价土地的冲击，无论是政府还是开发商都不愿意见到这种情况。另外，由于便宜的房子已经存在大量业主，强硬的拆违又容易引起社会问题，触犯另一批人的利益，所以目前这个问题可以说陷入了僵局。<br>经济适用房又分为经济适用房和按照经济适用房管理的商品房，后者多是体制内分房的产物。买房的时候你看一下房产证，是经济适用房的房子，房产证就写着经济适用房。经济适用房有的可以过户，有的不能过户。<br>我只能建议对这类房子感兴趣的读者，最好到政府过户大厅咨询一下自己考虑买的房子是不是“能过户的经济适用房”或“5年内（5年后）能过户的经济适用房”。如果不是，那么你买这个房子业主也是可以毁约的，依据是违反了《北京市经济适用房管理办法》。<br>也就是说，你买的房子到底是什么性质，要以房管局或者国土局的不动产登记簿的记载为准，也可以根据业主的房产证来确定。<br>如果是商品房，就可以直接交易过户。<br>如果是经济适用房，分成两种情况，一种是交易受到限制的，比如满5年才可以过户。一种是交易不受限制的，叫作按照经济适用房管理的住房，实际上就是商品房<br>抵债房，也叫顶账房，就是开发商资金链条断裂后，被债主拿在手里用于抵偿债务的房子。<br>虽然是抵债房，债主却不一定取得了房屋的产权。虽然开发商默认这个房子已经属于债主，但债主只是控制了这个房子，在法律上叫作占有。占有虽然也受到法律保护，但是和所有权比起来，要差一个档次。<br>计划经济时期，各单位分配的房子，由单位进行管理，叫作自管公房。城市里有不少老房子名义上被政府管理，实际上是由房管局管理的，叫作直管公房。公房被认为是一种属于承租人的财产——只不过难以流通。<br>这时就会涉及公房转为私房，叫作房改。或者公房改变承租人，叫作承租人变更。<br>公房的产权单位——房管局或者其他单位，作为房子的产权人，把原来和张三的租赁关系变更到李四名下，这就是公房的“过户手续”。看着和过户差不多，其实这并不是法律承认的交易形式。<br>按价格从低到高排序，小区可以分成如下几类：拆迁安置小区、老旧小区、单位小区、商住小区、新建商品房小区、高档商住小区、高档住宅小区、别墅小区。<br>。买房一定要先看房。我一般是先<br>用一天时间把所有的目标小区转一遍，然后再联系中介看房子。用两天时间走完问完，我在一个区域基本就是专家了，能确定我喜欢哪个小区。<br>一个住了10年的干净小区，一定比一个房龄只有1年的小区靠谱<br>怎么才能看出来小区物业好不好呢？有如下5个办法：•看小区有没有业委会•看小区楼道干净不干净•看小区电梯好用不好用（适用于房龄8年以上的小区）•看小区是不是谁都能进（安保是否严密）•去逛逛业主论坛，看有没有业主正在维权<br>地震的时候最先垮塌的都是形状奇怪的地方，比如飘窗，比如特别大的客厅。<br>房子结构分为砖混、钢混两种。<br>噪声和通风问题比较容易看出来，就是你把所有窗户都打开，听、感受，把窗户都关上，再听，要在每个房间尤其是卧室听。卖房的时候没有业主会跟你说房子通风不好、噪声太大、采光不好的，问他们没用，只有自己的感受最重要。有的人对噪声不敏感，有的人则对声音特别敏感。如果房子买了以后还有别人要住，或者你现在还不知道未来的对象是否对噪声敏感，那么你就尽量买个安静的房子。噪声问题是可以通过安装比较好的窗户来解决的。取暖问题也是一个考虑因素。屋子里头不暖和，到了冬天就不舒适。如果你买房的时候不是冬天，就只能靠这个小区其他邻居给你情报，看房子是看不出来的。楼层<br>没有产权证的房子尽量不要买，房产证上的名字必须和合同上的名字以及卖家身份证对得上。<br>解决办法就是拉产调（产权调查）。<br>购房人如果想要求稳妥，就把签约环节拆开，第一次只签一个定金合同支付定金，然后拉产调，之后第二次去签正式合同。<br>还有一个方案就是在签了正式合同之后先交定金，拉产调，然后再支付首付，这是比较通行的做法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/28/千万别说你懂买房/" data-id="cju85cakj00138suqivr1ebvu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习笔记/">学习笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-信息系统项目管理师" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/26/信息系统项目管理师/" class="article-date">
  <time datetime="2018-02-26T07:30:28.000Z" itemprop="datePublished">2018-02-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/26/信息系统项目管理师/">信息系统项目管理师知识点</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="每日一练总结"><a href="#每日一练总结" class="headerlink" title="每日一练总结"></a>每日一练总结</h1><h2 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h2><ul>
<li><p>一种非对称加密算法</p>
</li>
<li><p>算法的运行速度比DES慢</p>
</li>
<li><p>可用于某种数字签名方案</p>
</li>
<li><p>安全性主要基于素因子分解难度</p>
</li>
</ul>
<h2 id="投资回收期"><a href="#投资回收期" class="headerlink" title="投资回收期"></a>投资回收期</h2><p>指项目投建之日起用项目所得的净收益偿还原始投资所需的年限。</p>
<ul>
<li>静态投资回收期</li>
</ul>
<p>不考虑资金占用成本(时间价值)回收其全部投资所需的时间。</p>
<ul>
<li>动态投资回收期 </li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/26/信息系统项目管理师/" data-id="cju85caki00128suqpsvghoy2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/31/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/30/">30</a><a class="page-number" href="/page/31/">31</a><span class="page-number current">32</span><a class="page-number" href="/page/33/">33</a><a class="page-number" href="/page/34/">34</a><a class="page-number" href="/page/35/">35</a><a class="extend next" rel="next" href="/page/33/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/学习笔记/">学习笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/学习笔记/" style="font-size: 10px;">学习笔记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/04/03/CSS入门及提高/example/27 鼠标经过显示图片/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/04/02/CSS入门及提高/example/图片轮播/index/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/04/02/CSS入门及提高/example/26 绝对位置水平垂直居中/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/04/01/CSS入门及提高/example/学成网/index/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/03/28/mysql使用/">&#39;mysql使用&#39;</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>