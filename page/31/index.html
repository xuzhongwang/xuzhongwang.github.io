<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/31/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Web前端开发环境搭建" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/11/Web前端开发环境搭建/" class="article-date">
  <time datetime="2018-08-11T07:37:32.000Z" itemprop="datePublished">2018-08-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/11/Web前端开发环境搭建/">Web前端开发环境搭建</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h1><ul>
<li>Nodejs</li>
<li>grunt</li>
<li>bower</li>
<li>express</li>
<li>supervisor</li>
</ul>
<h2 id="grunt"><a href="#grunt" class="headerlink" title="grunt"></a>grunt</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g grunt cli</span><br></pre></td></tr></table></figure>
<p><img src="/2018/08/11/Web前端开发环境搭建/grunt安装.png" alt="Web前端开发环境搭建"></p>
<h2 id="bower"><a href="#bower" class="headerlink" title="bower"></a>bower</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install bower -g</span><br></pre></td></tr></table></figure>
<p><img src="/2018/08/11/Web前端开发环境搭建/bower安装.png" alt="Web前端开发环境搭建"></p>
<p>验证是否安装成功</p>
<p><img src="/2018/08/11/Web前端开发环境搭建/bower安装验证.png" alt="Web前端开发环境搭建"></p>
<h2 id="express"><a href="#express" class="headerlink" title="express"></a>express</h2><p>安装express，在cmd中输入：npm express -gd;   -g代表安装到NODE_PATH的lib里面，而-d代表把相依性套件也一起安装。如果沒有-g的话会安装目前所在的目录。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/11/Web前端开发环境搭建/" data-id="cjtifr91v001hwguqzvriscio" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JQuery源码解读" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/09/JQuery源码解读/" class="article-date">
  <time datetime="2018-08-09T08:08:08.000Z" itemprop="datePublished">2018-08-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/09/JQuery源码解读/">JQuery源码解读</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="AMD规范"><a href="#AMD规范" class="headerlink" title="AMD规范"></a>AMD规范</h1><h2 id="什么是ADM"><a href="#什么是ADM" class="headerlink" title="什么是ADM"></a>什么是ADM</h2><p>全称是Asynchronous Module Definition，即异步模块加载机制。<br>从它的规范描述页面看，AMD很短也很简单，但它却完整描述了模块的定义，依赖关系，引用关系以及加载机制。从它被requireJS，NodeJs，Dojo，JQuery使用也可以看出它具有很大的价值，没错，JQuery近期也采用了AMD规范。在这篇文章中，我们就将介绍AMD的性质，用法，优势以及应用场景。从AMD中我们也能学习到如何在更高层面去设计自己的前端应用。</p>
<h2 id="AMD构成"><a href="#AMD构成" class="headerlink" title="AMD构成"></a>AMD构成</h2><p>作为一个规范，只需定义其语法API，而不关心其实现。AMD规范简单到只有一个API，即define函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define([module-name?],[array-of-dependencies?],[module-factory-or-object])</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>module-name：模块标识，可以省略。</li>
<li>array-of-dependencies：所依赖的模块，可以省略。</li>
<li>module-factory-or-object：模块的实现，或者一个JavaScript对象。</li>
</ul>
<p>从这个define函数AMD中的A：Asynchronous，我们也不难想到define函数具有的另外一个性质，异步性。当define函数执行时，它首先会异步的去调用第二个参数中列出的依赖模块，当所有的模块被载入完成之后，如果第三个参数是一个回调函数则执行，然后告诉系统模块可用，也就通知了依赖于自己的模块自己已经可用。</p>
<h3 id="匿名模块"><a href="#匿名模块" class="headerlink" title="匿名模块"></a>匿名模块</h3><p>define 方法允许你省略第一个参数，这样就定义了一个匿名模块，这时候模块文件的文件名就是模块标识。</p>
<h1 id="jQuery-对象与-dom-对象转换"><a href="#jQuery-对象与-dom-对象转换" class="headerlink" title="jQuery 对象与 dom 对象转换"></a>jQuery 对象与 dom 对象转换</h1><h2 id="jQuery-转换成-dom-对象"><a href="#jQuery-转换成-dom-对象" class="headerlink" title="jQuery 转换成 dom 对象"></a>jQuery 转换成 dom 对象</h2><ul>
<li>[index]</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $j =$(<span class="string">"#j"</span>) ; <span class="comment">//jQuery对象</span></span><br><span class="line"><span class="keyword">var</span> d=$j[<span class="number">0</span>]; <span class="comment">//DOM对象</span></span><br></pre></td></tr></table></figure>
<ul>
<li>.get(index)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $j=$(<span class="string">"#v"</span>); <span class="comment">//jQuery对象</span></span><br><span class="line"><span class="keyword">var</span> d=$j.get(<span class="number">0</span>); <span class="comment">//DOM对象</span></span><br></pre></td></tr></table></figure>
<h2 id="dom-对象转换成-jQuery"><a href="#dom-对象转换成-jQuery" class="headerlink" title="dom 对象转换成 jQuery"></a>dom 对象转换成 jQuery</h2><p>对于已经是一个DOM对象，只需要用$()把DOM对象包装起来，就可以获得一个jQuery对象了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v=<span class="built_in">document</span>.getElementById(<span class="string">"v"</span>); <span class="comment">//DOM对象</span></span><br><span class="line"><span class="keyword">var</span> $v=$(v); <span class="comment">//jQuery对象</span></span><br></pre></td></tr></table></figure>
<h1 id="data"><a href="#data" class="headerlink" title="$.data()"></a>$.data()</h1><p>$.data(dom对象, ‘tree’);</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/09/JQuery源码解读/" data-id="cjtifr8xp000gwguqatq93dfo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Emmet语法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/08/Emmet语法/" class="article-date">
  <time datetime="2018-08-08T08:02:35.000Z" itemprop="datePublished">2018-08-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/08/Emmet语法/">Emmet语法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-Emmet-Html-语法"><a href="#1-Emmet-Html-语法" class="headerlink" title="1. Emmet Html 语法"></a>1. Emmet Html 语法</h1><h2 id="1-1-元素"><a href="#1-1-元素" class="headerlink" title="1.1. 元素"></a>1.1. 元素</h2><ul>
<li>输入元素名称，自动生成标签,如 div</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>输入 ! 或 html:5 自动补全基本结构</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="1-2-嵌套操作"><a href="#1-2-嵌套操作" class="headerlink" title="1.2. 嵌套操作"></a>1.2. 嵌套操作</h2><ul>
<li>child:使用 “&gt;” 生成子元素</li>
</ul>
<p>div&gt;ul&gt;li</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Sibling: 使用符号 “+” 生成兄弟元素</li>
</ul>
<p>div+p+bq</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blockquote</span>&gt;</span><span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Climb-up:使用 “^” 生成父元素，与 “&gt;” 相反</li>
</ul>
<p>div+div&gt;p&gt;span+em^bq</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">blockquote</span>&gt;</span><span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Multiplication:使用 “*” 操作符生成多个元素</li>
</ul>
<p>div&gt;ul&gt;li*5</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Grouping:使用 “()” 操作符将元素分组，实现更复杂的简写任务</li>
</ul>
<p>div&gt;(header&gt;ul&gt;li*2)+footer&gt;p</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="1-3-属性操作"><a href="#1-3-属性操作" class="headerlink" title="1.3. 属性操作"></a>1.3. 属性操作</h2><ul>
<li>id 与 class</li>
</ul>
<p>简写时，元素与 id 属性值之间用 “#” 分隔，与 class 属性值之间用 “.” 分隔。</p>
<p>div#header+div.page+div#footer.class1.class2.class3</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"header"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"page"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"footer"</span> <span class="attr">class</span>=<span class="string">"class1 class2 class3"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>其它属性</li>
</ul>
<p>使用 [attr] 标记添加其他属性。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">title</span>=<span class="string">"hello"</span> <span class="attr">colspan</span>=<span class="string">"3"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：</p>
<pre><code>- 方括号中可添加任意数量的属性
- 不给定属性值，则属性值为&quot;&quot;。td[colspan title]将得到

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">""</span> <span class="attr">title</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br></pre></td></tr></table></figure>

- 属性值可用单引号或双引号，输出统一为双引号
- 如果属性值中没有空格，则引号可省略
</code></pre><ul>
<li>为条目编号</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">li.item$*3</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item1"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item2"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item3"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可在 “$” 后添加 “@n” 修改编号的起始值为n。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">li.item$@3*3</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item3"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item4"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item5"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可在 “$” 后添加 “@-” 修改编号的方向。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">li.item$@-3*3</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item5"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item4"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item3"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="1-4-添加文本"><a href="#1-4-添加文本" class="headerlink" title="1.4. 添加文本"></a>1.4. 添加文本</h2><p>使用花括号 “{}” 操作符为元素添加文本节点。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// before</span><br><span class="line">a[href=me.htm]&#123;click me&#125;</span><br><span class="line"></span><br><span class="line">// after</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"me.htm"</span>&gt;</span>click me<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>因为文本也是节点，所以 a[href=me.htm]{click me} 与 a[href=me.htm]&gt;{click me} 等价。</p>
<p>但有多个元素时则要注意。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// before</span><br><span class="line">a[href=me.htm]&#123;click me&#125;+p&#123;ok&#125;</span><br><span class="line">a[href=me.htm]&gt;&#123;click me&#125;+p&#123;ok&#125;</span><br><span class="line"></span><br><span class="line">// after</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"me.htm"</span>&gt;</span>click me<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>ok<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"me.htm"</span>&gt;</span>click me</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>ok<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/08/Emmet语法/" data-id="cjtifr8xb0007wguqwspv1jmf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-理解JavaScript中的异步" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/08/理解JavaScript中的异步/" class="article-date">
  <time datetime="2018-08-08T01:21:48.000Z" itemprop="datePublished">2018-08-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/08/理解JavaScript中的异步/">理解JavaScript中的异步</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/08/理解JavaScript中的异步/" data-id="cjtifr8z4001cwguqkh7a3mdn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-打造自己的linqProvider" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/22/打造自己的linqProvider/" class="article-date">
  <time datetime="2018-07-22T07:04:18.000Z" itemprop="datePublished">2018-07-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/22/打造自己的linqProvider/">打造自己的linqProvider</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="认识表达式树"><a href="#认识表达式树" class="headerlink" title="认识表达式树"></a>认识表达式树</h1><p>表达式树是一种抽象语法或者数据结构，通过解析表达式目录可以实现一些特定功能。</p>
<p>如何构造表达式树，最简单的方法莫过于使用 Lambda 表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expression&lt;Func&lt;int,int,int&gt; expression = (a,b) =&gt; a*b +2;</span><br></pre></td></tr></table></figure>
<p>在我们将Lambda表达式指定给Expression&lt;TDelegate&gt;类型的变量（参数）时，编译器将会发出生成表达式目录树的指令，如上面这段代码中的Lambda表达式(a, b) =&gt; a * b + 2将创建一个表达式目录树，它表示的是一种数据结构，即我们把一行代码用数据结构的形式表示了出来，具体来说最终构造出来的表达式目录树形状如下图所示：</p>
<p><img src="/2018/07/22/打造自己的linqProvider/表达式目录树形状.png" alt="表达式目录树形状"></p>
<p>这里每一个节点都表示一个表达式，可能是一个二元运算，也可能是一个常量或者参数等，如上图中的ParameterExpression就是一个参数表达式，ConstantExpression是一个常量表达式，BinaryExpression是一个二元表达式。我们也可以在Visual Studio中使用Expression Tree Visualizer来查看该表达式目录树：</p>
<p>.NET Framework到底提供的表达式类型：</p>
<p><img src="/2018/07/22/打造自己的linqProvider/表达式类型.png" alt="表达式类型"></p>
<p>它们都继承于抽象的基类Expression，而泛型的Expression<tdelegate>则继承于LambdaExpression。在Expression类中提供了大量的工厂方法，这些方法负责创建以上各种表达式对象，如调用Add()方法将创建一个表示不进行溢出检查的算术加法运算的BinaryExpression对象，调用Lambda方法将创建一个表示lambda 表达式的LambdaExpression对象，具体提供的方法大家可以查阅MSDN。上面构造表达式目录树时我们使用了Lambda表达式，现在我们看一下如何通过这些表达式对象手工构造出一个表达式目录树，如下代码所示：</tdelegate></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    ParameterExpression paraLeft = Expression.Parameter(typeof(int), &quot;a&quot;);</span><br><span class="line">    ParameterExpression paraRight = Expression.Parameter(typeof(int), &quot;b&quot;);</span><br><span class="line"></span><br><span class="line">    BinaryExpression binaryLeft = Expression.Multiply(paraLeft, paraRight);</span><br><span class="line">    ConstantExpression conRight = Expression.Constant(2, typeof(int));</span><br><span class="line"></span><br><span class="line">    BinaryExpression binaryBody = Expression.Add(binaryLeft, conRight);</span><br><span class="line"></span><br><span class="line">    LambdaExpression lambda = </span><br><span class="line">        Expression.Lambda&lt;Func&lt;int, int, int&gt;&gt;(binaryBody, paraLeft, paraRight);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(lambda.ToString());</span><br><span class="line"></span><br><span class="line">    Console.Read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于一个表达式目录树来说，它有几个比较重要的属性：</p>
<ul>
<li>Body：指表达式的主体部分；</li>
<li>Parameters：指表达式的参数；</li>
<li>NodeType：指表达式的节点类型，如在上面的例子中，它的节点类型是Lambda；</li>
<li>Type：指表达式的静态类型，在上面的例子中，Type为Fun&lt;int,int,int&gt;。</li>
</ul>
<h2 id="表达式目录树与委托"><a href="#表达式目录树与委托" class="headerlink" title="表达式目录树与委托"></a>表达式目录树与委托</h2><p>大家可能经常看到如下这样的语言，其中第一句是直接用Lambda表达式来初始化了Func委托，而第二句则使用Lambda表达式来构造了一个表达式目录树，它们之间的区别是什么呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    Func&lt;int, int, int&gt; lambda = (a, b) =&gt; a + b * 2;</span><br><span class="line"></span><br><span class="line">    Expression&lt;Func&lt;int, int, int&gt;&gt; expression = (a, b) =&gt; a + b * 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实看一下IL就很明显，其中第一句直接将Lambda表达式直接编译成了IL，如下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.method private hidebysig static void  Main(string[] args) cil managed</span><br><span class="line">&#123;</span><br><span class="line">  .entrypoint</span><br><span class="line">  .maxstack  3</span><br><span class="line">  .locals init ([0] class [System.Core]System.Func`3&lt;int32,int32,int32&gt; lambda)</span><br><span class="line">  IL_0000:  nop</span><br><span class="line">  IL_0001:  ldsfld     class [System.Core]System.Func`3&lt;int32,int32,int32&gt; </span><br><span class="line">                        TerryLee.LinqToLiveSearch.Program::&apos;CS$&lt;&gt;9__CachedAnonymousMethodDelegate1&apos;</span><br><span class="line">  IL_0006:  brtrue.s   IL_001b</span><br><span class="line">  IL_0008:  ldnull</span><br><span class="line">  IL_0009:  ldftn      int32 TerryLee.LinqToLiveSearch.Program::&apos;&lt;Main&gt;b__0&apos;(int32,</span><br><span class="line">                                                                             int32)</span><br><span class="line">  IL_000f:  newobj     instance void class [System.Core]System.Func`3&lt;int32,int32,int32&gt;::.ctor(object,</span><br><span class="line">                                                                                                native int)</span><br><span class="line">  IL_0014:  stsfld     class [System.Core]System.Func`3&lt;int32,int32,int32&gt; </span><br><span class="line">                    TerryLee.LinqToLiveSearch.Program::&apos;CS$&lt;&gt;9__CachedAnonymousMethodDelegate1&apos;</span><br><span class="line">  IL_0019:  br.s       IL_001b</span><br><span class="line">  IL_001b:  ldsfld     class [System.Core]System.Func`3&lt;int32,int32,int32&gt; </span><br><span class="line">                    TerryLee.LinqToLiveSearch.Program::&apos;CS$&lt;&gt;9__CachedAnonymousMethodDelegate1&apos;</span><br><span class="line">  IL_0020:  stloc.0</span><br><span class="line">  IL_0021:  ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而第二句，由于告诉编译器是一个表达式目录树，所以编译器会分析该Lambda表达式，并生成表示该Lambda表达式的表达式目录树，即它与我们手工创建表达式目录树所生成的IL是一致的，如下代码所示，此处为了节省空间省略掉了部分代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">.method private hidebysig static void  Main(string[] args) cil managed</span><br><span class="line">&#123;</span><br><span class="line">  .entrypoint</span><br><span class="line">  .maxstack  4</span><br><span class="line">  .locals init ([0] class [System.Core]System.Linq.Expressions.Expression`1&lt;</span><br><span class="line">                class [System.Core]System.Func`3&lt;int32,int32,int32&gt;&gt; expression,</span><br><span class="line">           [1] class [System.Core]System.Linq.Expressions.ParameterExpression CS$0$0000,</span><br><span class="line">           [2] class [System.Core]System.Linq.Expressions.ParameterExpression CS$0$0001,</span><br><span class="line">           [3] class [System.Core]System.Linq.Expressions.ParameterExpression[] CS$0$0002)</span><br><span class="line">  IL_0000:  nop</span><br><span class="line">  IL_0001:  ldtoken    [mscorlib]System.Int32</span><br><span class="line">  IL_0006:  call       class [mscorlib]System.Type [mscorlib]System.Type::GetTypeFromHandle(...)</span><br><span class="line">  IL_000b:  ldstr      &quot;a&quot;</span><br><span class="line">  IL_0010:  call       class [System.Core]System.Linq.Expressions.ParameterExpression </span><br><span class="line">                        [System.Core]System.Linq.Expressions.Expression::Parameter(</span><br><span class="line">                        class [mscorlib]System.Type,</span><br><span class="line"></span><br><span class="line">  IL_0038:  call    class [mscorlib]System.Type [mscorlib]System.Type::GetTypeFromHandle()</span><br><span class="line">  IL_003d:  call    class [System.Core]System.Linq.Expressions.ConstantExpression </span><br><span class="line">                    [System.Core]System.Linq.Expressions.Expression::Constant(object,</span><br><span class="line">                    class [mscorlib]System.Type)</span><br><span class="line">  IL_0042:  call    class [System.Core]System.Linq.Expressions.BinaryExpression </span><br><span class="line">                    [System.Core]System.Linq.Expressions.Expression::Multiply(class [System.Core]System.Linq.Expressions.Expression,</span><br><span class="line">                    class [System.Core]System.Linq.Expressions.Expression)</span><br><span class="line">  IL_0047:  call    class [System.Core]System.Linq.Expressions.BinaryExpression</span><br><span class="line">                    [System.Core]System.Linq.Expressions.Expression::Add(class [System.Core]System.Linq.Expressions.Expression,</span><br><span class="line">                    class [System.Core]System.Linq.Expressions.Expression)</span><br><span class="line">  IL_004c:  ldc.i4.2</span><br><span class="line">  IL_004d:  newarr     [System.Core]System.Linq.Expressions.ParameterExpression</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在相信大家都看明白了，这里讲解它们的区别主要是为了加深大家对于表达式目录树的区别。</p>
<h2 id="执行表达式目录树"><a href="#执行表达式目录树" class="headerlink" title="执行表达式目录树"></a>执行表达式目录树</h2><p>前面已经可以构造出一个表达式目录树了，现在看看如何去执行表达式目录树。我们需要调用Compile方法来创建一个可执行委托，并且调用该委托，如下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    ParameterExpression paraLeft = Expression.Parameter(typeof(int), &quot;a&quot;);</span><br><span class="line">    ParameterExpression paraRight = Expression.Parameter(typeof(int), &quot;b&quot;);</span><br><span class="line"></span><br><span class="line">    BinaryExpression binaryLeft = Expression.Multiply(paraLeft, paraRight);</span><br><span class="line">    ConstantExpression conRight = Expression.Constant(2, typeof(int));</span><br><span class="line"></span><br><span class="line">    BinaryExpression binaryBody = Expression.Add(binaryLeft, conRight);</span><br><span class="line"></span><br><span class="line">    Expression&lt;Func&lt;int, int, int&gt;&gt; lambda = </span><br><span class="line">        Expression.Lambda&lt;Func&lt;int, int, int&gt;&gt;(binaryBody, paraLeft, paraRight);</span><br><span class="line"></span><br><span class="line">    Func&lt;int, int, int&gt; myLambda = lambda.Compile();</span><br><span class="line"></span><br><span class="line">    int result = myLambda(2, 3);</span><br><span class="line">    Console.WriteLine(&quot;result:&quot; + result.ToString());</span><br><span class="line"></span><br><span class="line">    Console.Read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后输出的结果：</p>
<p><img src="/2018/07/22/打造自己的linqProvider/lambda_result.png" alt="lambda_result"></p>
<p>这里我们只要简单的调用Compile方法就可以了，事实上在.NET Framework中是调用了一个名为ExpressionCompiler的内部类来做表达式目录树的执行（注意此处的Compiler不等同于编译器的编译）。另外，只能执行表示Lambda表达式的表达式目录树，即LambdaExpression或者Expression&lt;TDelegate&gt;类型。如果表达式目录树不是表示Lambda表达式，需要调用Lambda方法创建一个新的表达式。如下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    BinaryExpression body = Expression.Add(</span><br><span class="line">        Expression.Constant(2),</span><br><span class="line">        Expression.Constant(3));</span><br><span class="line"></span><br><span class="line">    Expression&lt;Func&lt;int&gt;&gt; expression = </span><br><span class="line">        Expression.Lambda&lt;Func&lt;int&gt;&gt;(body, null);</span><br><span class="line"></span><br><span class="line">    Func&lt;int&gt; lambda = expression.Compile();</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(lambda());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="访问与修改表达式目录树"><a href="#访问与修改表达式目录树" class="headerlink" title="访问与修改表达式目录树"></a>访问与修改表达式目录树</h2><p>在.NET Framework中，提供了一个抽象的表达式目录树访问类ExpressionVisitor，但它是一个internal的，我们不能直接访问。幸运的是，在MSDN中微软给出了ExpressionVisitor类的实现，我们可以直接拿来使用。该类是一个抽象类，微软旨在让我们在集成ExpressionVisitor的基础上，实现自己的表达式目录树访问类。现在我们来看简单的表达式目录树：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    Expression&lt;Func&lt;int, int, int&gt;&gt; lambda = (a, b) =&gt; a + b * 2;</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(lambda.ToString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出后为：</p>
<p><img src="/2018/07/22/打造自己的linqProvider/result2.png" alt="result2"></p>
<p>现在我们想要修改表达式目录树，让它表示的Lambda表达式为(a,b)=&gt;(a - (b * 2))，这时就需要编写自己的表达式目录树访问器，如下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class OperationsVisitor : ExpressionVisitor</span><br><span class="line">&#123;</span><br><span class="line">    public Expression Modify(Expression expression)</span><br><span class="line">    &#123;</span><br><span class="line">        return Visit(expression);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected override Expression VisitBinary(BinaryExpression b)</span><br><span class="line">    &#123;</span><br><span class="line">        if (b.NodeType == ExpressionType.Add)</span><br><span class="line">        &#123;</span><br><span class="line">            Expression left = this.Visit(b.Left);</span><br><span class="line">            Expression right = this.Visit(b.Right);</span><br><span class="line">            return Expression.Subtract(left,right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return base.VisitBinary(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用表达式目录树访问器来修改表达式目录树，如下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    Expression&lt;Func&lt;int, int, int&gt;&gt; lambda = (a, b) =&gt; a + b * 2;</span><br><span class="line"></span><br><span class="line">    var operationsVisitor = new OperationsVisitor();</span><br><span class="line">    Expression modifyExpression = operationsVisitor.Modify(lambda);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(modifyExpression.ToString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2018/07/22/打造自己的linqProvider/result3.png" alt="result3"></p>
<p>似乎我们是修改表达式目录树，其实也不全对，我们只是修改表达式目录树的一个副本而已，因为表达式目录树是不可变的，我们不能直接修改表达式目录树，看看上面的OperationsVisitor类的实现大家就知道了，在修改过程中复制了表达式目录树的节点。</p>
<h2 id="为什么需要表达式目录树"><a href="#为什么需要表达式目录树" class="headerlink" title="为什么需要表达式目录树"></a>为什么需要表达式目录树</h2><p>就拿LINQ to SQL为例</p>
<p><img src="/2018/07/22/打造自己的linqProvider/linq_to_sql.png" alt="linq_to_sql"></p>
<p>当我们在C#语言中编写一个查询表达式时，它将返回一个IQueryable类型的值，在该类型中包含了两个很重要的属性Expression和Provider，如下面的代码：</p>
<p><img src="/2018/07/22/打造自己的linqProvider/IQueryAble.png" alt="IQueryAble"></p>
<p>我们编写的查询表达式，将封装为一种抽象的数据结构，这个数据结构就是表达式目录树，当我们在使用上面返回的值时，编译器将会以该值所期望的方式进行翻译，这种方式就是由Expression和Provider来决定。可以看到，这样将会非常的灵活且具有良好的可扩展性，有了表达式目录树，可以自由的编写自己的Provider，去查询我们希望的数据源。经常说LINQ为访问各种不同的数据源提供了一种统一的编程方式，其奥秘就在这里。然而需要注意的是LINQ to Objects并不需要任何特定的LINQ Provider，因为它并不翻译为表达式目录树，后面会说到这一点。</p>
<h2 id="IEnumerable-lt-T-gt-接口"><a href="#IEnumerable-lt-T-gt-接口" class="headerlink" title="IEnumerable&lt;T&gt;接口"></a>IEnumerable&lt;T&gt;接口</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    List&lt;String&gt; myList = new List&lt;String&gt;() &#123; &quot;a&quot;, &quot;ab&quot;, &quot;cd&quot;, &quot;bd&quot; &#125;;</span><br><span class="line"></span><br><span class="line">    IEnumerable&lt;String&gt; query = from s in myList</span><br><span class="line">                where s.StartsWith(&quot;a&quot;)</span><br><span class="line">                select s;</span><br><span class="line"></span><br><span class="line">    foreach (String s in query)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Console.Read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2018/07/22/打造自己的linqProvider/result4.png" alt="result4"></p>
<p>为什么在LINQ to Objects中返回的是IEnumerable<t>类型的数据而不是IQueryable<t>呢？<br>在LINQ to Objects中查询表达式或者Lambda表达式并不翻译为表达式目录树，因为LINQ to Objects查询的都是实现了IEnmerable<t>接口的数据，所以查询表达式或者Lambda表达式都可以直接转换为.NET代码来执行，无需再经过转换为表达式目录这一步，这也是LINQ to Objects比较特殊的地方，它不需要特定的LINQ Provider。我们可以看一下IEnumerable<t>接口的实现，它里面并没有Expression和Provider这样的属性，如下图所示：</t></t></t></t></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface IEnumerable&lt;T&gt;:Ienumerable</span><br><span class="line">&#123;</span><br><span class="line">    IEnumerator&lt;T&gt; GetEnumerator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于LINQ to Objects中所有的标准查询操作符都是通过扩展方法来实现的，它们在抽象类Enumerable中定义，如其中的Where扩展方法如下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public static class Enumerable</span><br><span class="line">&#123;</span><br><span class="line">    public static IEnumerable&lt;TSource&gt; Where&lt;TSource&gt;(</span><br><span class="line">        this IEnumerable&lt;TSource&gt; source, </span><br><span class="line">        Func&lt;TSource, bool&gt; predicate)</span><br><span class="line">    &#123;</span><br><span class="line">        if (source == null)</span><br><span class="line">        &#123;</span><br><span class="line">            throw Error.ArgumentNull(&quot;source&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (predicate == null)</span><br><span class="line">        &#123;</span><br><span class="line">            throw Error.ArgumentNull(&quot;predicate&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return WhereIterator&lt;TSource&gt;(source, predicate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static IEnumerable&lt;TSource&gt; Where&lt;TSource&gt;(</span><br><span class="line">        this IEnumerable&lt;TSource&gt; source, </span><br><span class="line">        Func&lt;TSource, int, bool&gt; predicate)</span><br><span class="line">    &#123;</span><br><span class="line">        if (source == null)</span><br><span class="line">        &#123;</span><br><span class="line">            throw Error.ArgumentNull(&quot;source&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (predicate == null)</span><br><span class="line">        &#123;</span><br><span class="line">            throw Error.ArgumentNull(&quot;predicate&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return WhereIterator&lt;TSource&gt;(source, predicate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到这里方法的参数Func<tsource>系列委托，而非Expression&lt;Func<tsource>&gt;，在本文的后面，你将看到，IQueryable接口的数据，这些扩展方法的参数都是Expression&lt;Func<tsource>&gt;.</tsource></tsource></tsource></p>
<p>同样还有一点需要说明的是，在IEnumerable<t>中提供了一组扩展方法AsQueryable()，可以用来把一个IEnumerable<t>类型的数据转换为IQueryable<t>类型，如下代码所示：</t></t></t></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    var myList = new List&lt;String&gt;() </span><br><span class="line">                &#123; &quot;a&quot;, &quot;ab&quot;, &quot;cd&quot;, &quot;bd&quot; &#125;.AsQueryable&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    IQueryable&lt;String&gt; query = from s in myList</span><br><span class="line">                where s.StartsWith(&quot;a&quot;)</span><br><span class="line">                select s;</span><br><span class="line"></span><br><span class="line">    foreach (String s in query)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Console.Read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行这段代码，虽然它的输出结果与上面的示例完全相同，但它们查询的机制却完全不同：</p>
<h2 id="IQueryable-lt-T-gt-接口"><a href="#IQueryable-lt-T-gt-接口" class="headerlink" title="IQueryable&lt;T&gt;接口"></a>IQueryable&lt;T&gt;接口</h2><p><img src="/2018/07/22/打造自己的linqProvider/IQueryable定义.png" alt="IQueryable定义"></p>
<p>这里有两个很重要的属性Expression和Provider，分别表示获取与IQueryable 的实例关联的表达式目录树和获取与此数据源关联的查询提供程序，我们所有定义在查询表达式中方法调用或者Lambda表达式都将由该Expression属性表示，而最终会由Provider表示的提供程序翻译为它所对应的数据源的查询语言，这个数据源可能是数据库，XML文件或者是WebService等。该接口非常重要，在我们自定义LINQ Provider中必须要实现这个接口。同样对于IQueryable的标准查询操作都是由Queryable中的扩展方法来实现的，如下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public static class Queryable</span><br><span class="line">&#123;</span><br><span class="line">    public static IQueryable&lt;TSource&gt; Where&lt;TSource&gt;(this IQueryable&lt;TSource&gt; source, </span><br><span class="line">            Expression&lt;Func&lt;TSource, bool&gt;&gt; predicate)</span><br><span class="line">    &#123;</span><br><span class="line">        if (source == null)</span><br><span class="line">        &#123;</span><br><span class="line">            throw Error.ArgumentNull(&quot;source&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (predicate == null)</span><br><span class="line">        &#123;</span><br><span class="line">            throw Error.ArgumentNull(&quot;predicate&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return source.Provider.CreateQuery&lt;TSource&gt;(</span><br><span class="line">            Expression.Call(null, ((MethodInfo) MethodBase.GetCurrentMethod())</span><br><span class="line">            .MakeGenericMethod(new Type[] &#123; typeof(TSource) &#125;), </span><br><span class="line">            new Expression[] &#123; source.Expression, Expression.Quote(predicate) &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static IQueryable&lt;TSource&gt; Where&lt;TSource&gt;(this IQueryable&lt;TSource&gt; source,</span><br><span class="line">        Expression&lt;Func&lt;TSource, int, bool&gt;&gt; predicate)</span><br><span class="line">    &#123;</span><br><span class="line">        if (source == null)</span><br><span class="line">        &#123;</span><br><span class="line">            throw Error.ArgumentNull(&quot;source&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (predicate == null)</span><br><span class="line">        &#123;</span><br><span class="line">            throw Error.ArgumentNull(&quot;predicate&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return source.Provider.CreateQuery&lt;TSource&gt;(</span><br><span class="line">            Expression.Call(null, ((MethodInfo) MethodBase.GetCurrentMethod())</span><br><span class="line">            .MakeGenericMethod(new Type[] &#123; typeof(TSource) &#125;), </span><br><span class="line">            new Expression[] &#123; source.Expression, Expression.Quote(predicate) &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后还有一点，如果我们定义的查询需要支持Orderby等操作，还必须实现IOrderedQueryable&lt;T&gt; 接口，它继承自IQueryable&lt;T&gt;，如下图所示：</p>
<p><img src="/2018/07/22/打造自己的linqProvider/IOrderedQueryable.png" alt="IOrderedQueryable"></p>
<h2 id="IQueryProvider接口"><a href="#IQueryProvider接口" class="headerlink" title="IQueryProvider接口"></a>IQueryProvider接口</h2><p>在认识了IQueryable接口之后，我们再来看看在自定义LINQ Provider中另一个非常重要的接口IQueryProvider。它的定义如下图所示：</p>
<p><img src="/2018/07/22/打造自己的linqProvider/IQueryProvider.png" alt="IQueryProvider"></p>
<p>看到这里两组方法的参数，其实大家已经可以知道，Provider负责执行表达式目录树并返回结果。如果是LINQ to SQL的Provider，则它会负责把表达式目录树翻译为T-SQL语句并并传递给数据库服务器，并返回最后的执行的结果；如果是一个Web Service的Provider，则它会负责翻译表达式目录树并调用Web Service，最终返回结果。<br>这里四个方法其实就两个操作CreateQuery和Execute（分别有泛型和非泛型），CreateQuery方法用于构造一个 IQueryable<t> 对象，该对象可计算指定表达式目录树所表示的查询，返回的结果是一个可枚举的类型，；而Execute执行指定表达式目录树所表示的查询，返回的结果是一个单一值。自定义一个最简单的LINQ Provider，至少需要实现IQueryable<t>和IQueryProvider两个接口，在下篇文章中，你将看到一个综合的实例。</t></t></p>
<h2 id="扩展LINQ的两种方式"><a href="#扩展LINQ的两种方式" class="headerlink" title="扩展LINQ的两种方式"></a>扩展LINQ的两种方式</h2><p>通过前面的讲解，我们可以想到，对于LINQ的扩展有两种方式，一是借助于LINQ to Objects，如果我们所做的查询直接在.NET代码中执行，就可以实现IEnumerable<t>接口，而无须再去实现IQueryable并编写自定义的LINQ Provider，如.NET中内置的List<t>等。如我们可以编写一段简单自定义代码：</t></t></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class MyData&lt;T&gt; : IEnumerable&lt;T&gt;</span><br><span class="line">                where T : class</span><br><span class="line">&#123;</span><br><span class="line">    public IEnumerator&lt;T&gt; GetEnumerator()</span><br><span class="line">    &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IEnumerator IEnumerable.GetEnumerator()</span><br><span class="line">    &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 其它成员</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种扩展LINQ的方式当然就是自定义LINQ Provider了，我们需要实现IQueryable<t>和IQueryProvider两个接口，下面先给出一段简单的示意代码，在下一篇中我们将完整的来实现一个LINQ Provider。如下代码所示：</t></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">public class QueryableData&lt;TData&gt; : IQueryable&lt;TData&gt;</span><br><span class="line">&#123;</span><br><span class="line">    public QueryableData()</span><br><span class="line">    &#123;</span><br><span class="line">        Provider = new TerryQueryProvider();</span><br><span class="line">        Expression = Expression.Constant(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public QueryableData(TerryQueryProvider provider, </span><br><span class="line">        Expression expression)</span><br><span class="line">    &#123;</span><br><span class="line">        if (provider == null)</span><br><span class="line">        &#123;</span><br><span class="line">            throw new ArgumentNullException(&quot;provider&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (expression == null)</span><br><span class="line">        &#123;</span><br><span class="line">            throw new ArgumentNullException(&quot;expression&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!typeof(IQueryable&lt;TData&gt;).IsAssignableFrom(expression.Type))</span><br><span class="line">        &#123;</span><br><span class="line">            throw new ArgumentOutOfRangeException(&quot;expression&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Provider = provider;</span><br><span class="line">        Expression = expression;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public IQueryProvider Provider &#123; get; private set; &#125;</span><br><span class="line">    public Expression Expression &#123; get; private set; &#125;</span><br><span class="line"></span><br><span class="line">    public Type ElementType</span><br><span class="line">    &#123;</span><br><span class="line">        get &#123; return typeof(TData); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public IEnumerator&lt;TData&gt; GetEnumerator()</span><br><span class="line">    &#123;</span><br><span class="line">        return (Provider.Execute&lt;IEnumerable&lt;TData&gt;&gt;(Expression)).GetEnumerator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IEnumerator IEnumerable.GetEnumerator()</span><br><span class="line">    &#123;</span><br><span class="line">        return (Provider.Execute&lt;IEnumerable&gt;(Expression)).GetEnumerator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TerryQueryProvider : IQueryProvider</span><br><span class="line">&#123;</span><br><span class="line">    public IQueryable CreateQuery(Expression expression)</span><br><span class="line">    &#123;</span><br><span class="line">        Type elementType = TypeSystem.GetElementType(expression.Type);</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            return (IQueryable)Activator.CreateInstance(</span><br><span class="line">                typeof(QueryableData&lt;&gt;).MakeGenericType(elementType),</span><br><span class="line">                new object[] &#123; this, expression &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        catch</span><br><span class="line">        &#123;</span><br><span class="line">            throw new Exception();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public IQueryable&lt;TResult&gt; CreateQuery&lt;TResult&gt;(Expression expression)</span><br><span class="line">    &#123;</span><br><span class="line">        return new QueryableData&lt;TResult&gt;(this, expression);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public object Execute(Expression expression)</span><br><span class="line">    &#123;</span><br><span class="line">        // ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public TResult Execute&lt;TResult&gt;(Expression expression)</span><br><span class="line">    &#123;</span><br><span class="line">        // ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这两个接口都没有完成，这里只是示意性的代码，如果实现了这两个接口，我们就可以像下面这样使用了（当然这样的使用是没有意义的，这里只是为了演示）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    QueryableData&lt;String&gt; mydata = new QueryableData&lt;String&gt; &#123; </span><br><span class="line">        &quot;TerryLee&quot;,</span><br><span class="line">        &quot;Cnblogs&quot;,</span><br><span class="line">        &quot;Dingxue&quot;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var result = from d in mydata</span><br><span class="line">                 select d;</span><br><span class="line">    foreach (String item in result)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在再来分析一下这个执行过程，首先是实例化QueryableData<string>，同时也会实例化TerryQueryProvider；当执行查询表达式的时候，会调用TerryQueryProvider中的CreateQuery方法，来构造表达式目录树，此时查询并不会被真正执行（即延迟加载），只有当我们调用GetEnumerator方法，上例中的foreach，此时会调用TerryQueryProvider中的Execute方法，此时查询才会被真正执行，如下图所示：</string></p>
<p><img src="/2018/07/22/打造自己的linqProvider/执行过程.png" alt="执行过程"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/22/打造自己的linqProvider/" data-id="cjtifr8za001gwguqtxqm6nag" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CSS入门及提高" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/21/CSS入门及提高/" class="article-date">
  <time datetime="2018-07-21T06:30:58.000Z" itemprop="datePublished">2018-07-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/21/CSS入门及提高/">CSS入门及提高</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-CSS-样式规则"><a href="#1-CSS-样式规则" class="headerlink" title="1. CSS 样式规则"></a>1. CSS 样式规则</h1><p><img src="/2018/07/21/CSS入门及提高/CSS样式规则.png" alt="CSS入门及提高"></p>
<h1 id="2-字体设置"><a href="#2-字体设置" class="headerlink" title="2. 字体设置"></a>2. 字体设置</h1><h2 id="2-1-字体综合设置"><a href="#2-1-字体综合设置" class="headerlink" title="2.1. 字体综合设置"></a>2.1. 字体综合设置</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择器 &#123;<span class="attribute">font</span>: font-style font-weight font-size/line-weight font-family;&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li><p>顺序不能变.</p>
</li>
<li><p>不需要设置的属性可以省略，取默认值，但必须保留 font-size 与 font-family</p>
</li>
</ul>
<h1 id="3-选择器"><a href="#3-选择器" class="headerlink" title="3. 选择器"></a>3. 选择器</h1><h2 id="3-1-标签选择器（元素选择器）"><a href="#3-1-标签选择器（元素选择器）" class="headerlink" title="3.1. 标签选择器（元素选择器）"></a>3.1. 标签选择器（元素选择器）</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">标签名 &#123; 属性1:属性值1;属性2：属性值2&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-类选择器"><a href="#3-2-类选择器" class="headerlink" title="3.2. 类选择器"></a>3.2. 类选择器</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.类名 &#123;属性1:属性值1;属性2：属性值2&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-3-id-选择器"><a href="#3-3-id-选择器" class="headerlink" title="3.3. id 选择器"></a>3.3. id 选择器</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#id名 &#123;属性1:属性值1;属性2：属性值2&#125;</span><br></pre></td></tr></table></figure>
<p>id 选择器与 类选择器的区别：在使用次数上，类选择器可以使用多次，id 选择器只能使用一次</p>
<h2 id="3-4-通配符选择器"><a href="#3-4-通配符选择器" class="headerlink" title="3.4. 通配符选择器"></a>3.4. 通配符选择器</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* &#123;属性1:属性值1;属性2：属性值2&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-5-伪类选择器"><a href="#3-5-伪类选择器" class="headerlink" title="3.5. 伪类选择器"></a>3.5. 伪类选择器</h2><h3 id="3-5-1-链接伪类选择器"><a href="#3-5-1-链接伪类选择器" class="headerlink" title="3.5.1. 链接伪类选择器"></a>3.5.1. 链接伪类选择器</h3><ul>
<li>:link  未访问的链接</li>
<li>:visited 已访问的链接</li>
<li>:hover 鼠标移动到链接上</li>
<li>:active 选定的链接，选定不松开时</li>
</ul>
<p>注意：顺序不能颠倒</p>
<h3 id="3-5-2-结构伪类选择器"><a href="#3-5-2-结构伪类选择器" class="headerlink" title="3.5.2. 结构伪类选择器"></a>3.5.2. 结构伪类选择器</h3><ul>
<li>:first-child 选取属于其父元素的首个子元素的指定选择器</li>
<li>:last-child 选取属于其父元素的最后一个子元素的指定选择器</li>
<li>:nth-child(n)  选取第n个,n从0开始,n可以是公式</li>
<li>:nth-last-child(n) 从最后一个元素开始,</li>
</ul>
<h3 id="3-5-3-目标伪类选择器"><a href="#3-5-3-目标伪类选择器" class="headerlink" title="3.5.3. 目标伪类选择器"></a>3.5.3. 目标伪类选择器</h3><p>:target 目标伪类选择器，选择器可用于选取当前活动的目标元素。</p>
<h1 id="4-文字"><a href="#4-文字" class="headerlink" title="4. 文字"></a>4. 文字</h1><h2 id="4-1-文字阴影"><a href="#4-1-文字阴影" class="headerlink" title="4.1. 文字阴影"></a>4.1. 文字阴影</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">text-shadow</span>: 水平位置，垂直位置，模糊距离，阴影颜色</span><br></pre></td></tr></table></figure>
<h2 id="4-2-文本的装饰"><a href="#4-2-文本的装饰" class="headerlink" title="4.2. 文本的装饰"></a>4.2. 文本的装饰</h2><table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>none</td>
<td>默认，定义标准的文本</td>
</tr>
<tr>
<td>underline</td>
<td>定义文本下的一条线</td>
</tr>
<tr>
<td>overline</td>
<td>定义文本上的一条线</td>
</tr>
<tr>
<td>line-through</td>
<td>定义穿过文本下的一条线</td>
</tr>
</tbody>
</table>
<h1 id="5-css样式表"><a href="#5-css样式表" class="headerlink" title="5. css样式表"></a>5. css样式表</h1><table>
<thead>
<tr>
<th>样式表</th>
<th>优点</th>
<th>缺点</th>
<th>使用情况</th>
<th>控制范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>内部样式表</td>
<td>书写方便，权重高</td>
<td>没有实现样式和结构相分离</td>
<td>较少</td>
<td>控制一个标签（少） </td>
</tr>
<tr>
<td>行内样式表</td>
<td>部分结构与样式分离</td>
<td>没有彻底分离</td>
<td>较多</td>
<td>控制一个页面（中）</td>
</tr>
<tr>
<td>外部样式表</td>
<td>完全实现结构与样式分离</td>
<td>需要引入</td>
<td>最多，强烈推荐</td>
<td>控制整个站点（多）</td>
</tr>
</tbody>
</table>
<h2 id="5-1-标签的显示形式"><a href="#5-1-标签的显示形式" class="headerlink" title="5.1. 标签的显示形式"></a>5.1. 标签的显示形式</h2><p>HTML 标签一般分为块标签和行内标签两种类型，它们也称块元素和行内元素</p>
<h3 id="5-1-1-块级元素"><a href="#5-1-1-块级元素" class="headerlink" title="5.1.1. 块级元素"></a>5.1.1. 块级元素</h3><p>每个块级元素通常都会独自占据一整行或多行，可以对其设置宽度、高度、对齐等属性，常用于网页布局和网页结构搭建。</p>
<p>常见的元素有：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">h1</span>&gt;...&lt;<span class="selector-tag">h6</span>&gt;、&lt;<span class="selector-tag">p</span>&gt;、&lt;<span class="selector-tag">div</span>&gt;、&lt;<span class="selector-tag">ul</span>&gt;、&lt;<span class="selector-tag">ol</span>&gt;、&lt;<span class="selector-tag">li</span>&gt;等</span><br></pre></td></tr></table></figure>
<p>特点：</p>
<ul>
<li>总是从新行开始</li>
<li>宽度、行高、外边距及内边距都可以控制</li>
<li>宽度默认是容器的100%</li>
<li>可以容纳其它内联元素和其他块元素</li>
</ul>
<h3 id="5-1-2-行内元素"><a href="#5-1-2-行内元素" class="headerlink" title="5.1.2. 行内元素"></a>5.1.2. 行内元素</h3><p>行内元素（内联元素）不占有独立的区域，仅仅靠自身的字体大小和图像尺寸来支撑结构，一般不可以设置宽度、高度、对齐等属性，常用开控制页面中文本的样式。</p>
<p>常见的行内元素有</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">a</span>&gt; &lt;<span class="selector-tag">strong</span>&gt; &lt;<span class="selector-tag">b</span>&gt; &lt;<span class="selector-tag">em</span>&gt; &lt;<span class="selector-tag">i</span>&gt; &lt;<span class="selector-tag">del</span>&gt; &lt;<span class="selector-tag">ins</span>&gt; &lt;<span class="selector-tag">u</span>&gt; &lt;<span class="selector-tag">span</span>&gt;</span><br></pre></td></tr></table></figure>
<p>特点：</p>
<ul>
<li>和相邻行内元素在一行内显示</li>
<li>高、宽无效，但水平方向的 padding 和 margin 可以设置，垂直方向的无效。</li>
<li>默认宽度就是它本身内容的宽度</li>
<li>行内元素只能容纳文本或者其他行内元素（a特殊)</li>
</ul>
<p>注意：</p>
<ul>
<li>只有文字能组成段落，因此 p 里面不能放块级元素，同理 h1~h6</li>
<li>链接里面不能再放链接</li>
</ul>
<h3 id="5-1-3-行内块元素-inline-block"><a href="#5-1-3-行内块元素-inline-block" class="headerlink" title="5.1.3. 行内块元素(inline-block)"></a>5.1.3. 行内块元素(inline-block)</h3><p>在行内元素中有几个特殊的标签 &lt;img/&gt;、&lt;input/&gt;、&lt;td&gt; 可以对它们设置宽度和对齐属性</p>
<p>特点：</p>
<ul>
<li>和相邻行内元素（行内块）在一行上，但是之间会有空白缝隙。</li>
<li>默认宽度就是它本身内容的宽度（宽度由内容决定）</li>
<li>高度，行高，外边距以及内边距都可以控制。</li>
</ul>
<h3 id="5-1-4-显示模式转换"><a href="#5-1-4-显示模式转换" class="headerlink" title="5.1.4. 显示模式转换"></a>5.1.4. 显示模式转换</h3><p>块转行内： display:inline;<br>行内转块： display:block;<br>块、行内元素转行内块： display:inline-block;</p>
<h1 id="6-复合选择器"><a href="#6-复合选择器" class="headerlink" title="6. 复合选择器"></a>6. 复合选择器</h1><h2 id="6-1-交集选择器"><a href="#6-1-交集选择器" class="headerlink" title="6.1. 交集选择器"></a>6.1. 交集选择器</h2><p><img src="/2018/07/21/CSS入门及提高/交集选择器.png" alt="交集选择器"></p>
<h2 id="6-2-并集选择器"><a href="#6-2-并集选择器" class="headerlink" title="6.2. 并集选择器"></a>6.2. 并集选择器</h2><p><img src="/2018/07/21/CSS入门及提高/并集选择器.png" alt="并集选择器"></p>
<h2 id="6-3-后代选择器"><a href="#6-3-后代选择器" class="headerlink" title="6.3. 后代选择器"></a>6.3. 后代选择器</h2><p><img src="/2018/07/21/CSS入门及提高/后代选择器.png" alt="后代选择器"></p>
<h2 id="6-4-子元素选择器"><a href="#6-4-子元素选择器" class="headerlink" title="6.4. 子元素选择器"></a>6.4. 子元素选择器</h2><p><img src="/2018/07/21/CSS入门及提高/子元素选择器.png" alt="子元素选择器"></p>
<h2 id="6-5-属性选择器"><a href="#6-5-属性选择器" class="headerlink" title="6.5. 属性选择器"></a>6.5. 属性选择器</h2><p>选取标签带有某些特殊属性的选择器</p>
<table>
<thead>
<tr>
<th>选择器</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>E[attr]</td>
<td>存在 attr 属性即可</td>
</tr>
<tr>
<td>E[attr=val]</td>
<td>属性值完全等于 val</td>
</tr>
<tr>
<td>E[attr*=val]</td>
<td>属性值包含 val 字符并且在“任意”位置</td>
</tr>
<tr>
<td>E[attr^=val]</td>
<td>属性值包含 val 字符并且在“开始”位置</td>
</tr>
<tr>
<td>E[attr$=val]</td>
<td>属性值包含 val 字符并且在“结束”位置</td>
</tr>
</tbody>
</table>
<h2 id="6-6-伪元素选择器（CSS3"><a href="#6-6-伪元素选择器（CSS3" class="headerlink" title="6.6. 伪元素选择器（CSS3)"></a>6.6. 伪元素选择器（CSS3)</h2><ul>
<li>E::first-letter 文本的第一个单词或字</li>
<li>E::first-line 文本第一行</li>
<li>E::selection 可改变选中文本的样式</li>
<li>E::before和 E::after 在E元素内部开始的位置和结束位创建一个元素，该元素为行内元素，且必须结合content属性使用</li>
</ul>
<h1 id="7-CSS-书写规范"><a href="#7-CSS-书写规范" class="headerlink" title="7. CSS 书写规范"></a>7. CSS 书写规范</h1><h2 id="7-1-空格规范"><a href="#7-1-空格规范" class="headerlink" title="7.1. 空格规范"></a>7.1. 空格规范</h2><p>【强制】选择器与{}之间必须包含空格<br>【强制】属性名与之后的：之间不允许包含空格，：与属性值之间必须包含空格.<br>示例：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">font-size</span>: 12<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure>
<h2 id="7-2-选择器规范"><a href="#7-2-选择器规范" class="headerlink" title="7.2. 选择器规范"></a>7.2. 选择器规范</h2><p>【强制】当一个 rule 包含多个 selector 时，每个选择器声明必须独占一行。<br>【建议】选择器嵌套层级不大于3级，位置靠后的限定条件应尽可能精确。</p>
<h2 id="7-3-属性规范"><a href="#7-3-属性规范" class="headerlink" title="7.3. 属性规范"></a>7.3. 属性规范</h2><p>【强制】属性定义必须另起一行<br>【强制】属性定义后必须以分号结尾</p>
<h1 id="8-CSS-背景"><a href="#8-CSS-背景" class="headerlink" title="8. CSS 背景"></a>8. CSS 背景</h1><h2 id="8-1-多背景"><a href="#8-1-多背景" class="headerlink" title="8.1. 多背景"></a>8.1. 多背景</h2><ul>
<li>一个元素可以设置多重背景图像</li>
<li>每组属性之间使用逗号隔开</li>
<li>如果设置的多重背景之间存在着交集（即存在着重叠关系），前面的背景图片会覆盖在后面的背景图片上。</li>
<li>为了避免背景色将图像盖住，背景色通常定义在最后一组上。</li>
</ul>
<h1 id="9-CSS-三大特性"><a href="#9-CSS-三大特性" class="headerlink" title="9. CSS 三大特性"></a>9. CSS 三大特性</h1><h2 id="9-1-层叠性"><a href="#9-1-层叠性" class="headerlink" title="9.1. 层叠性"></a>9.1. 层叠性</h2><p>样式冲突遵循的原则是就近原则，哪个样式离着结构近就执行哪个样式。</p>
<h2 id="9-2-继承性"><a href="#9-2-继承性" class="headerlink" title="9.2. 继承性"></a>9.2. 继承性</h2><p>子元素可以继承父元素的样式，如 text- font- line- 以及 color属性</p>
<h2 id="9-3-优先性"><a href="#9-3-优先性" class="headerlink" title="9.3. 优先性"></a>9.3. 优先性</h2><p>权重表</p>
<table>
<thead>
<tr>
<th>继承或者*的贡献值</th>
<th>0,0,0,0</th>
</tr>
</thead>
<tbody>
<tr>
<td>每个元素（标签）贡献值为</td>
<td>0,0,0,1</td>
</tr>
<tr>
<td>每个类、伪类贡献值为</td>
<td>0,0,1,0</td>
</tr>
<tr>
<td>每个ID贡献值为</td>
<td>0,１,0,0</td>
</tr>
<tr>
<td>每个行内样式贡献值为</td>
<td>1,0,0,0</td>
</tr>
<tr>
<td>每个!important贡献值为</td>
<td>无穷大</td>
</tr>
</tbody>
</table>
<p>继承的权重为0</p>
<h1 id="10-盒子模型"><a href="#10-盒子模型" class="headerlink" title="10. 盒子模型"></a>10. 盒子模型</h1><h2 id="10-1-外边距合并"><a href="#10-1-外边距合并" class="headerlink" title="10.1. 外边距合并"></a>10.1. 外边距合并</h2><h3 id="10-1-1-相邻元素块垂直外边距合并"><a href="#10-1-1-相邻元素块垂直外边距合并" class="headerlink" title="10.1.1. 相邻元素块垂直外边距合并"></a>10.1.1. 相邻元素块垂直外边距合并</h3><p>不是两者相加的和，而是取两者中的较大者。</p>
<h3 id="10-1-2-嵌套元素垂直外边距合并"><a href="#10-1-2-嵌套元素垂直外边距合并" class="headerlink" title="10.1.2. 嵌套元素垂直外边距合并"></a>10.1.2. 嵌套元素垂直外边距合并</h3><p>对于两个嵌套关系的块元素，如果父元素没有上边距及边框，则父元素的上边距会与子元素的上边距发生合并，合并后的外边距为两者中的较大者。</p>
<p>解决方案：</p>
<ul>
<li>可以为父元素定义1像素的上边框或上内边距。</li>
<li>可以为父元素添加overflow:hidden</li>
</ul>
<h2 id="10-2-盒子的计算尺寸"><a href="#10-2-盒子的计算尺寸" class="headerlink" title="10.2. 盒子的计算尺寸"></a>10.2. 盒子的计算尺寸</h2><p>注意：</p>
<ul>
<li>宽度属性和高度属性仅适用于块级元素，对行内元素无效（img标签和input除外）</li>
<li>计算盒子模型的总高度时，还应考虑上下两个盒子垂直外边距合并的情况</li>
<li>如果一个盒子没有给定宽度/高度或者继承父亲的宽度/高度,则padding不会影响本盒子大小。</li>
</ul>
<h2 id="10-3-盒子模型与布局稳定性"><a href="#10-3-盒子模型与布局稳定性" class="headerlink" title="10.3. 盒子模型与布局稳定性"></a>10.3. 盒子模型与布局稳定性</h2><p>稳定性<br>width &gt; padding &gt; margin</p>
<h2 id="10-4-CSS3-盒模型"><a href="#10-4-CSS3-盒模型" class="headerlink" title="10.4. CSS3 盒模型"></a>10.4. CSS3 盒模型</h2><ol>
<li>box-sizing:content-box 盒子大小为 width + padding + border ,此值为默认值，W2C标准的Box Mode</li>
<li>box-sizing:border-box 盒子大小为 width</li>
</ol>
<h2 id="10-5-盒子阴影"><a href="#10-5-盒子阴影" class="headerlink" title="10.5. 盒子阴影"></a>10.5. 盒子阴影</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">box-shadow</span> 水平位置 垂直位置 模糊距离 阴影尺寸 阴影颜色  内外阴影</span><br></pre></td></tr></table></figure>
<h2 id="10-6-浮动"><a href="#10-6-浮动" class="headerlink" title="10.6. 浮动"></a>10.6. 浮动</h2><p>CSS 定位机制有3种：普通流（标准流）、浮动和定位</p>
<ul>
<li>普通流(normal flow) ：自上而下，自左而右</li>
<li>浮动：最开始用来做文字环绕效果</li>
</ul>
<h3 id="什么是浮动"><a href="#什么是浮动" class="headerlink" title="什么是浮动"></a>什么是浮动</h3><p>元素浮动是指设置了浮动属性的元素会脱离标准普通流的控制，移动到其父元素中指定位置的过程。</p>
<h3 id="浮动与行内块"><a href="#浮动与行内块" class="headerlink" title="浮动与行内块"></a>浮动与行内块</h3><p>行内块之间有难以却除的间隙<br>行内元素或块级元素添加浮动后变为行内块</p>
<h2 id="版心和布局流程"><a href="#版心和布局流程" class="headerlink" title="版心和布局流程"></a>版心和布局流程</h2><ul>
<li>确定页面的版心</li>
<li>分析页面中的行模块，以及每个行模块中的列模块</li>
<li>制作HTML结构</li>
<li>CSS初始化，然后开始运用盒子模型的原理，通过 DIV+CSS布局来控制网页中的各个模块。</li>
</ul>
<h3 id="清除浮动的本质"><a href="#清除浮动的本质" class="headerlink" title="清除浮动的本质"></a>清除浮动的本质</h3><p>清除浮动主要是为了解决父级元素因为子级浮动引起内部高度为0的问题。</p>
<p>清除方法</p>
<ul>
<li>额外标签法：在浮动元素末尾添加一个空的标签，例如 </li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"clear:both"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>优点：通俗易懂，书写方便<br>缺点：添加许多无意义的标签，结构化差。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>内容（例子）</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>额外标签法</td>
<td>在浮动元素末尾添加一个空的标签，例如：&lt;div style=”clear:both”&gt;&lt;/div&gt;</td>
<td>通俗易懂，书写方便</td>
<td>添加许多无意义的标签，结构化差</td>
</tr>
<tr>
<td>父级增加overflow属性方法</td>
<td>给父级元素增加overflow为hidden或auto或scroll都可以实现</td>
<td>代码简洁</td>
<td>内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素</td>
</tr>
<tr>
<td>使用after伪元素</td>
<td>.clearfix:after{content:”.”;display:block;height:0;visibility:hidden;clear:both}</td>
<td>符合闭合浮动思维，结构主义化明确</td>
<td>由于IE6-7不支持after,使用zoom:1触发 hasLayout</td>
</tr>
<tr>
<td>双伪元素</td>
<td>.clearfix:before,.clearfix:after{content:””,display:table}  .clearfix:after{clear:both} .clearfix{*zoom:1;}</td>
<td>代码更简洁</td>
<td>由于IE6-7不支持after,使用zoom:1触发 hasLayout</td>
</tr>
</tbody>
</table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/21/CSS入门及提高/" data-id="cjtifr8xf000awguqkqrbhdh1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-从零做一个前端开源项目学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/18/从零做一个前端开源项目学习笔记/" class="article-date">
  <time datetime="2018-07-18T11:28:43.000Z" itemprop="datePublished">2018-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/18/从零做一个前端开源项目学习笔记/">从零做一个前端开源项目学习笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="什么是开源"><a href="#什么是开源" class="headerlink" title="什么是开源"></a>什么是开源</h1><p>开源包括：</p>
<ul>
<li>源码</li>
<li>文档，如二次开发文档和用户使用文档</li>
<li>开发环境，告诉二次开发者如何搭建和运行代码</li>
<li>允许他人贡献代码：而不是仅仅给别人阅读代码的权限</li>
<li>问题：用户提问，维护者答复，问题共享</li>
<li>问题列表和升级计划：记录当前问题，以及何时解决、何时升级</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/18/从零做一个前端开源项目学习笔记/" data-id="cjtifr8yp0010wguq3qrb4ocs" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="&#39;sql-SQL Server编程入门经典" class="article article-type-&#39;sql" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/09/SQL Server编程入门经典/" class="article-date">
  <time datetime="2018-07-09T01:09:25.000Z" itemprop="datePublished">2018-07-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/09/SQL Server编程入门经典/">SQL Server编程入门经典</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-RDBMS-基础：SQLServer-数据库的构成"><a href="#1-RDBMS-基础：SQLServer-数据库的构成" class="headerlink" title="1. RDBMS 基础：SQLServer 数据库的构成"></a>1. RDBMS 基础：SQLServer 数据库的构成</h1><h2 id="1-1-数据对象的概述"><a href="#1-1-数据对象的概述" class="headerlink" title="1.1. 数据对象的概述"></a>1.1. 数据对象的概述</h2><p>数据库对象：</p>
<ul>
<li>数据库本身</li>
<li>事务日志</li>
<li>表</li>
<li>索引</li>
<li>文件组</li>
<li>数据库关系图</li>
<li>视图</li>
<li>存储过程</li>
<li>用户自定义函数</li>
<li>序列</li>
<li>用户</li>
<li>角色</li>
<li>程序集</li>
<li>报表</li>
<li>全文目录</li>
<li>用户自定义数据类型</li>
</ul>
<h3 id="1-1-1-数据库对象"><a href="#1-1-1-数据库对象" class="headerlink" title="1.1.1. 数据库对象"></a>1.1.1. 数据库对象</h3><p>存储过程和视图是对存储在数据库表中的数据的特定分组</p>
<p>SQL Server 第一次启动时至少包括4个系统数据库</p>
<ul>
<li>master：系统表用于系统的总体控件</li>
<li>model：是指可以基于该模型得一个副本</li>
<li>msdb：SQL Agent 进程存储任意系统任务的地方</li>
<li>tempdb：是服务器的主要工作地方之一。在执行一个复杂或者大型的查询操作时，SQL Server可能需要创建一些中间表来完成该操作。每次启动SQLServer,tempdb数据库是系统中唯一完全重建的数据库。</li>
</ul>
<h3 id="1-1-2-事务日志"><a href="#1-1-2-事务日志" class="headerlink" title="1.1.2. 事务日志"></a>1.1.2. 事务日志</h3><p>实际上，任意数据库的更改起初不进入数据库本身，而是不断地被写入到事务日志。<br>日志是数据进入磁盘上的最先位置，且稍后会被传播到实际的数据库。需要数据库文件和事务日志一起完成数据库功能。</p>
<h3 id="1-1-3-最基本的数据库对象：表"><a href="#1-1-3-最基本的数据库对象：表" class="headerlink" title="1.1.3. 最基本的数据库对象：表"></a>1.1.3. 最基本的数据库对象：表</h3><ol>
<li>索引</li>
</ol>
<p>索引分两类：</p>
<ul>
<li>群集索引：每个表只能有一个群集索引，如果为百科全书做索引，则群集索引是书的页码</li>
<li>非群集索引：每个表可以有多个非群集索引。</li>
</ul>
<p>注意：具有索引的视图在有非群集索引之前必须有一个群集索引</p>
<ol start="2">
<li>触发器</li>
</ol>
<p>触发器有多种用途，但主要用于输入时复制数据或在更新时检查数据，确保数据满足相应条件。</p>
<ol start="3">
<li>约束</li>
</ol>
<h3 id="1-1-4-文件组"><a href="#1-1-4-文件组" class="headerlink" title="1.1.4. 文件组"></a>1.1.4. 文件组</h3><h3 id="1-1-5-数据库关系图"><a href="#1-1-5-数据库关系图" class="headerlink" title="1.1.5. 数据库关系图"></a>1.1.5. 数据库关系图</h3><h3 id="1-1-6-视图"><a href="#1-1-6-视图" class="headerlink" title="1.1.6. 视图"></a>1.1.6. 视图</h3><p>视图仅仅是表中所存储数据的一个预先计划的映射和表示。视图以查询的形式存储在数据库中。</p>
<p>视图的主要目的是控制视图用户查看的数据。</p>
<p>索引视图除了可以创建索引外，其它都与视图相同，其对使用性能的影响如下：</p>
<ul>
<li>对于引用多个表的视图来说，索引视图的可读性更好，因为它预告构建了表之间的连接。</li>
<li>由于预先计算好视图中执行的聚合(aggregation)，并将其作为索引的一部分存储，因此聚合只要执行一次（在插入或更新时），然后就可从索引信息中直接读取它。</li>
<li>由于视图上的索引必须及时更新，因此插入和删除索引需要更多的系统开销，如果更新影响到索引的键列或群集键，则更新也需要更多的系统开销。</li>
</ul>
<h3 id="1-1-7-存储过程"><a href="#1-1-7-存储过程" class="headerlink" title="1.1.7. 存储过程"></a>1.1.7. 存储过程</h3><p>存储过程优点：</p>
<ul>
<li>不使用长字符中文本而使用短字符串存储过程名，可减少运行存储过程中的代码所需要的网络通信流量。</li>
<li>预先优化和预编译，节省每次运行存储过程的时间。</li>
<li>通常考虑安全原因，或仅仅隐藏数据库的复杂性，将过程封装。</li>
<li>可从其它存储过程调用，使得它们在某些限定意义上重用。</li>
</ul>
<h3 id="1-1-8-用户自定义函数"><a href="#1-1-8-用户自定义函数" class="headerlink" title="1.1.8. 用户自定义函数"></a>1.1.8. 用户自定义函数</h3><p>用户自定义函数（UDF）与存储过程十分相似，不同之处有如下几点：</p>
<ul>
<li>返回值的数据类型包括大部分 SQLServer 数据类型。不包括的返回值数据类型有：text,ntext,image,cursor,timestamp</li>
<li>没有“副作用”。基本上用户自定义函数不能超出函数的作用范围。</li>
</ul>
<p>传送到函数中的所有变量都是按值传递的，但可以返回一种特殊的数据类型–表</p>
<h3 id="1-1-9-序列"><a href="#1-1-9-序列" class="headerlink" title="1.1.9. 序列"></a>1.1.9. 序列</h3><p>序列的作用是提供任意数量的进程都可以访问的序号源，同时保证任意两个进程不会同时获取相同的下一个值。因为序列是单独存在的对象(没有绑定到任何表),所以它可以有多种用途。</p>
<h3 id="1-1-10-用户和角色"><a href="#1-1-10-用户和角色" class="headerlink" title="1.1.10. 用户和角色"></a>1.1.10. 用户和角色</h3><h3 id="1-1-11-规则"><a href="#1-1-11-规则" class="headerlink" title="1.1.11. 规则"></a>1.1.11. 规则</h3><h3 id="1-1-12-默认值"><a href="#1-1-12-默认值" class="headerlink" title="1.1.12. 默认值"></a>1.1.12. 默认值</h3><p>SQL Server 中有两种类型的默认值，包括对象本身的默认值，以及描述表中特定列的元数据的默认值。</p>
<h3 id="1-1-13-用户自定义数据类型"><a href="#1-1-13-用户自定义数据类型" class="headerlink" title="1.1.13. 用户自定义数据类型"></a>1.1.13. 用户自定义数据类型</h3><h3 id="1-1-14-全文目录"><a href="#1-1-14-全文目录" class="headerlink" title="1.1.14. 全文目录"></a>1.1.14. 全文目录</h3><h2 id="1-2-SQL-Server-数据类型"><a href="#1-2-SQL-Server-数据类型" class="headerlink" title="1.2. SQL Server 数据类型"></a>1.2. SQL Server 数据类型</h2><p><img src="/2018/07/09/SQL Server编程入门经典/SQL_Server编程入门经典/数据类型1.png" alt="数据类型1"><br><img src="/2018/07/09/SQL Server编程入门经典/SQL_Server编程入门经典/数据类型2.png" alt="数据类型2"></p>
<h1 id="2-连接"><a href="#2-连接" class="headerlink" title="2. 连接"></a>2. 连接</h1><p>数据库规范化是指将数据从更大的表分割成几个较小的表，目的是消除重复的数据、节省空间、提高数据库性能，并增加数据完整性。</p>
<h2 id="2-1-内部连接"><a href="#2-1-内部连接" class="headerlink" title="2.1. 内部连接"></a>2.1. 内部连接</h2><p>INNER JOIN:内部连接是一个排他的连接，即排除在两表————第一个指定的表（即左表）和第二个指定表（即右表）————中没有匹配的所有记录。</p>
<h3 id="2-1-1-处理更复杂的外部连接"><a href="#2-1-1-处理更复杂的外部连接" class="headerlink" title="2.1.1. 处理更复杂的外部连接"></a>2.1.1. 处理更复杂的外部连接</h3><p>在所有的查询的语句中，JOIN 左侧或之前的所有表只作为一个表，不论查询语句是要包含或排除表中的数据。同样，所有查询语句中 JOIN 右侧或之后的所有表只作为一个表。</p>
<p>通常，应首先使用内部连接，然后尽量少地使用外部连接，这样可以减少代码中的错误。</p>
<h2 id="2-2-联合"><a href="#2-2-联合" class="headerlink" title="2.2. 联合"></a>2.2. 联合</h2><p>JOIN 将信息水平连接（添加更多列），而 UNION 将数据垂直连接（添加更多行）。</p>
<h1 id="3-创建和修改数据表"><a href="#3-创建和修改数据表" class="headerlink" title="3. 创建和修改数据表"></a>3. 创建和修改数据表</h1><h2 id="3-1-SQL-SERVER-中的对象名"><a href="#3-1-SQL-SERVER-中的对象名" class="headerlink" title="3.1. SQL SERVER 中的对象名"></a>3.1. SQL SERVER 中的对象名</h2><p>有4层命名约定</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ServerName.[DatabaseName.[SchemaName.]]]ObjectName</span><br></pre></td></tr></table></figure>
<h1 id="4-刍和约束"><a href="#4-刍和约束" class="headerlink" title="4. 刍和约束"></a>4. 刍和约束</h1><p>确保数据完整性不是使用数据库的程序的责任，而是数据库本身的责任。</p>
<p>有3种不同类型的约束</p>
<ul>
<li>实体约束</li>
<li>域约束</li>
<li>参照完整笥约束</li>
</ul>
<p>约束的方法</p>
<ul>
<li>主键约束</li>
<li>外键约束</li>
<li>唯一约束(也称替换键)</li>
<li>CHECK约束</li>
<li>DEFAULT约束</li>
<li>规则</li>
<li>默认值(和DEFAULT约束类似)</li>
</ul>
<h2 id="4-1-约束的类型"><a href="#4-1-约束的类型" class="headerlink" title="4.1. 约束的类型"></a>4.1. 约束的类型</h2><h3 id="4-1-1-域约束"><a href="#4-1-1-域约束" class="headerlink" title="4.1.1. 域约束"></a>4.1.1. 域约束</h3><p>域约束处理一个或多个列</p>
<h2 id="4-2-键约束"><a href="#4-2-键约束" class="headerlink" title="4.2. 键约束"></a>4.2. 键约束</h2><p>主键、外键、替换键和倒置健</p>
<h1 id="5-更复杂的查询"><a href="#5-更复杂的查询" class="headerlink" title="5. 更复杂的查询"></a>5. 更复杂的查询</h1><h2 id="5-1-子查询的概念"><a href="#5-1-子查询的概念" class="headerlink" title="5.1. 子查询的概念"></a>5.1. 子查询的概念</h2><p>子查询通常用于满足下列某个需求</p>
<ul>
<li>将一个查询分解为一系列的逻辑步骤</li>
<li>提供一个列表作为 WHERE 子句和 [IN|EXIST|ANY|ALL]的目标</li>
<li>为父查询中的每个记录提供一个查询表</li>
</ul>
<h2 id="5-2-关联子查询"><a href="#5-2-关联子查询" class="headerlink" title="5.2. 关联子查询"></a>5.2. 关联子查询</h2><p>关联子查询与嵌套子查询的不同之处在于：信息传递是双向的，而不是单向的。在嵌套子查询中，内部查询只处理一次，然后将信息传递到外部查询，而外部查询也只执行一次————提供和您自己可能输入的完全相同的值或列表。</p>
<p>关联子查询处理过程</p>
<ul>
<li>外部查询获取一个记录，然后将该记录传递到内部查询</li>
<li>内部查询根据传递的值进行查询</li>
<li>内部查询将结果值传递回外部查询，而外部查询利用这些值完成处理过程。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/09/SQL Server编程入门经典/" data-id="cjtifr8ya000pwguq7s1kzgu1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CLR via C#学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/05/CLR via C#学习笔记/" class="article-date">
  <time datetime="2018-07-05T00:49:53.470Z" itemprop="datePublished">2018-07-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="什么是CLR"><a href="#什么是CLR" class="headerlink" title="什么是CLR"></a>什么是CLR</h2><p>是一种可由多种编程语言共同使用的运行时。</p>
<h2 id="CLR的核心功能"><a href="#CLR的核心功能" class="headerlink" title="CLR的核心功能"></a>CLR的核心功能</h2><p>内存管理、程序集加载、安全性、异常处理和线程同步</p>
<h2 id="程序集"><a href="#程序集" class="headerlink" title="程序集"></a>程序集</h2><p>程序集是一个或多个模块\资源文件的逻辑性分组<br>程序集是重用、安全性以及版本控制的最小单元</p>
<h2 id="IL的最大优势"><a href="#IL的最大优势" class="headerlink" title="IL的最大优势"></a>IL的最大优势</h2><p>IL的最大优势并不在于它对底层CPU的抽象。而在于其提供的应用程序的健壮性和安全性。</p>
<h2 id="unsafe关键字"><a href="#unsafe关键字" class="headerlink" title="unsafe关键字"></a>unsafe关键字</h2><p>C#编译器要求包含不安全代码的所有方法都用unsafe关键字标记。</p>
<h1 id="本地代码生成器：NGen-exe"><a href="#本地代码生成器：NGen-exe" class="headerlink" title="本地代码生成器：NGen.exe"></a>本地代码生成器：NGen.exe</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/05/CLR via C#学习笔记/" data-id="cjtifr8x70005wguq6nhcg8p1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ModelUI for WPF" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/08/ModelUI for WPF/" class="article-date">
  <time datetime="2018-03-08T00:53:36.000Z" itemprop="datePublished">2018-03-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/08/ModelUI for WPF/">ModelUI for WPF</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="使用ModelUI"><a href="#使用ModelUI" class="headerlink" title="使用ModelUI"></a>使用ModelUI</h1><h2 id="首先获取相关dll"><a href="#首先获取相关dll" class="headerlink" title="首先获取相关dll"></a>首先获取相关dll</h2><p>[github地址]：<a href="https://github.com/firstfloorsoftware/mui" target="_blank" rel="noopener">https://github.com/firstfloorsoftware/mui</a></p>
<h2 id="在项目中添加引用"><a href="#在项目中添加引用" class="headerlink" title="在项目中添加引用"></a>在项目中添加引用</h2><p>在目录FirstFloor.ModernUI\FirstFloor.ModernUI\bin\Debug下找到FirstFloor.ModernUI.dll,添加到你所需要的wpf项目中</p>
<p>在项目的App.xaml中添加如下代码</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Application</span> <span class="attr">x:Class</span>=<span class="string">"SuperRecite.App"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">xmlns</span>=<span class="string">"http://schemas.microsoft.com/winfx/2006/xaml/presentation"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">xmlns:x</span>=<span class="string">"http://schemas.microsoft.com/winfx/2006/xaml"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">xmlns:local</span>=<span class="string">"clr-namespace:SuperRecite"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">StartupUri</span>=<span class="string">"MainWindow.xaml"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Application.Resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ResourceDictionary</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ResourceDictionary.MergedDictionaries</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ResourceDictionary</span> <span class="attr">Source</span>=<span class="string">"/FirstFloor.ModernUI;component/Assets/ModernUI.xaml"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ResourceDictionary</span> <span class="attr">Source</span>=<span class="string">"/FirstFloor.ModernUI;component/Assets/ModernUI.Light.xaml"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ResourceDictionary.MergedDictionaries</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ResourceDictionary</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Application.Resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Application</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在项目的主页面中添加引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlns:mui=&quot;http://firstfloorsoftware.com/ModernUI&quot;</span><br></pre></td></tr></table></figure>
<p> 主窗体后台改变继承的基类</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public partial class MainWindow : ModernWindow</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/08/ModelUI for WPF/" data-id="cjtifr8yc000qwguqhtivu4wa" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/30/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/29/">29</a><a class="page-number" href="/page/30/">30</a><span class="page-number current">31</span><a class="page-number" href="/page/32/">32</a><a class="page-number" href="/page/33/">33</a><span class="space">&hellip;</span><a class="page-number" href="/page/35/">35</a><a class="extend next" rel="next" href="/page/32/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/学习笔记/">学习笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/学习笔记/" style="font-size: 10px;">学习笔记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/03/22/CSS入门及提高/example/25 使用双伪元素清除浮动/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/03/22/CSS入门及提高/example/24 通栏平均分布布局/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/03/22/CSS入门及提高/example/23 两列左窄右宽布局/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/03/22/CSS入门及提高/example/22 横向布局/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/03/21/EasyUI-插件开发/jquery-easyui-ribbon/themes/metro/window/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>