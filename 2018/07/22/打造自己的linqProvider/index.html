<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>打造自己的linqProvider | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="认识表达式树表达式树是一种抽象语法或者数据结构，通过解析表达式目录可以实现一些特定功能。 如何构造表达式树，最简单的方法莫过于使用 Lambda 表达式 1Expression&amp;lt;Func&amp;lt;int,int,int&amp;gt; expression = (a,b) =&amp;gt; a*b +2; 在我们将Lambda表达式指定给Expression&amp;lt;TDelegate&amp;gt;类型的变量（参数">
<meta property="og:type" content="article">
<meta property="og:title" content="打造自己的linqProvider">
<meta property="og:url" content="http://yoursite.com/2018/07/22/打造自己的linqProvider/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="认识表达式树表达式树是一种抽象语法或者数据结构，通过解析表达式目录可以实现一些特定功能。 如何构造表达式树，最简单的方法莫过于使用 Lambda 表达式 1Expression&amp;lt;Func&amp;lt;int,int,int&amp;gt; expression = (a,b) =&amp;gt; a*b +2; 在我们将Lambda表达式指定给Expression&amp;lt;TDelegate&amp;gt;类型的变量（参数">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/2018/07/22/打造自己的linqProvider/表达式目录树形状.png">
<meta property="og:image" content="http://yoursite.com/2018/07/22/打造自己的linqProvider/表达式类型.png">
<meta property="og:image" content="http://yoursite.com/2018/07/22/打造自己的linqProvider/lambda_result.png">
<meta property="og:image" content="http://yoursite.com/2018/07/22/打造自己的linqProvider/result2.png">
<meta property="og:image" content="http://yoursite.com/2018/07/22/打造自己的linqProvider/result3.png">
<meta property="og:image" content="http://yoursite.com/2018/07/22/打造自己的linqProvider/linq_to_sql.png">
<meta property="og:image" content="http://yoursite.com/2018/07/22/打造自己的linqProvider/IQueryAble.png">
<meta property="og:image" content="http://yoursite.com/2018/07/22/打造自己的linqProvider/result4.png">
<meta property="og:image" content="http://yoursite.com/2018/07/22/打造自己的linqProvider/IQueryable定义.png">
<meta property="og:image" content="http://yoursite.com/2018/07/22/打造自己的linqProvider/IOrderedQueryable.png">
<meta property="og:image" content="http://yoursite.com/2018/07/22/打造自己的linqProvider/IQueryProvider.png">
<meta property="og:image" content="http://yoursite.com/2018/07/22/打造自己的linqProvider/执行过程.png">
<meta property="og:updated_time" content="2018-07-22T08:08:35.927Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="打造自己的linqProvider">
<meta name="twitter:description" content="认识表达式树表达式树是一种抽象语法或者数据结构，通过解析表达式目录可以实现一些特定功能。 如何构造表达式树，最简单的方法莫过于使用 Lambda 表达式 1Expression&amp;lt;Func&amp;lt;int,int,int&amp;gt; expression = (a,b) =&amp;gt; a*b +2; 在我们将Lambda表达式指定给Expression&amp;lt;TDelegate&amp;gt;类型的变量（参数">
<meta name="twitter:image" content="http://yoursite.com/2018/07/22/打造自己的linqProvider/表达式目录树形状.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-打造自己的linqProvider" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/22/打造自己的linqProvider/" class="article-date">
  <time datetime="2018-07-22T07:04:18.000Z" itemprop="datePublished">2018-07-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      打造自己的linqProvider
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="认识表达式树"><a href="#认识表达式树" class="headerlink" title="认识表达式树"></a>认识表达式树</h1><p>表达式树是一种抽象语法或者数据结构，通过解析表达式目录可以实现一些特定功能。</p>
<p>如何构造表达式树，最简单的方法莫过于使用 Lambda 表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expression&lt;Func&lt;int,int,int&gt; expression = (a,b) =&gt; a*b +2;</span><br></pre></td></tr></table></figure>
<p>在我们将Lambda表达式指定给Expression&lt;TDelegate&gt;类型的变量（参数）时，编译器将会发出生成表达式目录树的指令，如上面这段代码中的Lambda表达式(a, b) =&gt; a * b + 2将创建一个表达式目录树，它表示的是一种数据结构，即我们把一行代码用数据结构的形式表示了出来，具体来说最终构造出来的表达式目录树形状如下图所示：</p>
<p><img src="/2018/07/22/打造自己的linqProvider/表达式目录树形状.png" alt="表达式目录树形状"></p>
<p>这里每一个节点都表示一个表达式，可能是一个二元运算，也可能是一个常量或者参数等，如上图中的ParameterExpression就是一个参数表达式，ConstantExpression是一个常量表达式，BinaryExpression是一个二元表达式。我们也可以在Visual Studio中使用Expression Tree Visualizer来查看该表达式目录树：</p>
<p>.NET Framework到底提供的表达式类型：</p>
<p><img src="/2018/07/22/打造自己的linqProvider/表达式类型.png" alt="表达式类型"></p>
<p>它们都继承于抽象的基类Expression，而泛型的Expression<tdelegate>则继承于LambdaExpression。在Expression类中提供了大量的工厂方法，这些方法负责创建以上各种表达式对象，如调用Add()方法将创建一个表示不进行溢出检查的算术加法运算的BinaryExpression对象，调用Lambda方法将创建一个表示lambda 表达式的LambdaExpression对象，具体提供的方法大家可以查阅MSDN。上面构造表达式目录树时我们使用了Lambda表达式，现在我们看一下如何通过这些表达式对象手工构造出一个表达式目录树，如下代码所示：</tdelegate></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    ParameterExpression paraLeft = Expression.Parameter(typeof(int), &quot;a&quot;);</span><br><span class="line">    ParameterExpression paraRight = Expression.Parameter(typeof(int), &quot;b&quot;);</span><br><span class="line"></span><br><span class="line">    BinaryExpression binaryLeft = Expression.Multiply(paraLeft, paraRight);</span><br><span class="line">    ConstantExpression conRight = Expression.Constant(2, typeof(int));</span><br><span class="line"></span><br><span class="line">    BinaryExpression binaryBody = Expression.Add(binaryLeft, conRight);</span><br><span class="line"></span><br><span class="line">    LambdaExpression lambda = </span><br><span class="line">        Expression.Lambda&lt;Func&lt;int, int, int&gt;&gt;(binaryBody, paraLeft, paraRight);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(lambda.ToString());</span><br><span class="line"></span><br><span class="line">    Console.Read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于一个表达式目录树来说，它有几个比较重要的属性：</p>
<ul>
<li>Body：指表达式的主体部分；</li>
<li>Parameters：指表达式的参数；</li>
<li>NodeType：指表达式的节点类型，如在上面的例子中，它的节点类型是Lambda；</li>
<li>Type：指表达式的静态类型，在上面的例子中，Type为Fun&lt;int,int,int&gt;。</li>
</ul>
<h2 id="表达式目录树与委托"><a href="#表达式目录树与委托" class="headerlink" title="表达式目录树与委托"></a>表达式目录树与委托</h2><p>大家可能经常看到如下这样的语言，其中第一句是直接用Lambda表达式来初始化了Func委托，而第二句则使用Lambda表达式来构造了一个表达式目录树，它们之间的区别是什么呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    Func&lt;int, int, int&gt; lambda = (a, b) =&gt; a + b * 2;</span><br><span class="line"></span><br><span class="line">    Expression&lt;Func&lt;int, int, int&gt;&gt; expression = (a, b) =&gt; a + b * 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实看一下IL就很明显，其中第一句直接将Lambda表达式直接编译成了IL，如下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.method private hidebysig static void  Main(string[] args) cil managed</span><br><span class="line">&#123;</span><br><span class="line">  .entrypoint</span><br><span class="line">  .maxstack  3</span><br><span class="line">  .locals init ([0] class [System.Core]System.Func`3&lt;int32,int32,int32&gt; lambda)</span><br><span class="line">  IL_0000:  nop</span><br><span class="line">  IL_0001:  ldsfld     class [System.Core]System.Func`3&lt;int32,int32,int32&gt; </span><br><span class="line">                        TerryLee.LinqToLiveSearch.Program::&apos;CS$&lt;&gt;9__CachedAnonymousMethodDelegate1&apos;</span><br><span class="line">  IL_0006:  brtrue.s   IL_001b</span><br><span class="line">  IL_0008:  ldnull</span><br><span class="line">  IL_0009:  ldftn      int32 TerryLee.LinqToLiveSearch.Program::&apos;&lt;Main&gt;b__0&apos;(int32,</span><br><span class="line">                                                                             int32)</span><br><span class="line">  IL_000f:  newobj     instance void class [System.Core]System.Func`3&lt;int32,int32,int32&gt;::.ctor(object,</span><br><span class="line">                                                                                                native int)</span><br><span class="line">  IL_0014:  stsfld     class [System.Core]System.Func`3&lt;int32,int32,int32&gt; </span><br><span class="line">                    TerryLee.LinqToLiveSearch.Program::&apos;CS$&lt;&gt;9__CachedAnonymousMethodDelegate1&apos;</span><br><span class="line">  IL_0019:  br.s       IL_001b</span><br><span class="line">  IL_001b:  ldsfld     class [System.Core]System.Func`3&lt;int32,int32,int32&gt; </span><br><span class="line">                    TerryLee.LinqToLiveSearch.Program::&apos;CS$&lt;&gt;9__CachedAnonymousMethodDelegate1&apos;</span><br><span class="line">  IL_0020:  stloc.0</span><br><span class="line">  IL_0021:  ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而第二句，由于告诉编译器是一个表达式目录树，所以编译器会分析该Lambda表达式，并生成表示该Lambda表达式的表达式目录树，即它与我们手工创建表达式目录树所生成的IL是一致的，如下代码所示，此处为了节省空间省略掉了部分代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">.method private hidebysig static void  Main(string[] args) cil managed</span><br><span class="line">&#123;</span><br><span class="line">  .entrypoint</span><br><span class="line">  .maxstack  4</span><br><span class="line">  .locals init ([0] class [System.Core]System.Linq.Expressions.Expression`1&lt;</span><br><span class="line">                class [System.Core]System.Func`3&lt;int32,int32,int32&gt;&gt; expression,</span><br><span class="line">           [1] class [System.Core]System.Linq.Expressions.ParameterExpression CS$0$0000,</span><br><span class="line">           [2] class [System.Core]System.Linq.Expressions.ParameterExpression CS$0$0001,</span><br><span class="line">           [3] class [System.Core]System.Linq.Expressions.ParameterExpression[] CS$0$0002)</span><br><span class="line">  IL_0000:  nop</span><br><span class="line">  IL_0001:  ldtoken    [mscorlib]System.Int32</span><br><span class="line">  IL_0006:  call       class [mscorlib]System.Type [mscorlib]System.Type::GetTypeFromHandle(...)</span><br><span class="line">  IL_000b:  ldstr      &quot;a&quot;</span><br><span class="line">  IL_0010:  call       class [System.Core]System.Linq.Expressions.ParameterExpression </span><br><span class="line">                        [System.Core]System.Linq.Expressions.Expression::Parameter(</span><br><span class="line">                        class [mscorlib]System.Type,</span><br><span class="line"></span><br><span class="line">  IL_0038:  call    class [mscorlib]System.Type [mscorlib]System.Type::GetTypeFromHandle()</span><br><span class="line">  IL_003d:  call    class [System.Core]System.Linq.Expressions.ConstantExpression </span><br><span class="line">                    [System.Core]System.Linq.Expressions.Expression::Constant(object,</span><br><span class="line">                    class [mscorlib]System.Type)</span><br><span class="line">  IL_0042:  call    class [System.Core]System.Linq.Expressions.BinaryExpression </span><br><span class="line">                    [System.Core]System.Linq.Expressions.Expression::Multiply(class [System.Core]System.Linq.Expressions.Expression,</span><br><span class="line">                    class [System.Core]System.Linq.Expressions.Expression)</span><br><span class="line">  IL_0047:  call    class [System.Core]System.Linq.Expressions.BinaryExpression</span><br><span class="line">                    [System.Core]System.Linq.Expressions.Expression::Add(class [System.Core]System.Linq.Expressions.Expression,</span><br><span class="line">                    class [System.Core]System.Linq.Expressions.Expression)</span><br><span class="line">  IL_004c:  ldc.i4.2</span><br><span class="line">  IL_004d:  newarr     [System.Core]System.Linq.Expressions.ParameterExpression</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在相信大家都看明白了，这里讲解它们的区别主要是为了加深大家对于表达式目录树的区别。</p>
<h2 id="执行表达式目录树"><a href="#执行表达式目录树" class="headerlink" title="执行表达式目录树"></a>执行表达式目录树</h2><p>前面已经可以构造出一个表达式目录树了，现在看看如何去执行表达式目录树。我们需要调用Compile方法来创建一个可执行委托，并且调用该委托，如下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    ParameterExpression paraLeft = Expression.Parameter(typeof(int), &quot;a&quot;);</span><br><span class="line">    ParameterExpression paraRight = Expression.Parameter(typeof(int), &quot;b&quot;);</span><br><span class="line"></span><br><span class="line">    BinaryExpression binaryLeft = Expression.Multiply(paraLeft, paraRight);</span><br><span class="line">    ConstantExpression conRight = Expression.Constant(2, typeof(int));</span><br><span class="line"></span><br><span class="line">    BinaryExpression binaryBody = Expression.Add(binaryLeft, conRight);</span><br><span class="line"></span><br><span class="line">    Expression&lt;Func&lt;int, int, int&gt;&gt; lambda = </span><br><span class="line">        Expression.Lambda&lt;Func&lt;int, int, int&gt;&gt;(binaryBody, paraLeft, paraRight);</span><br><span class="line"></span><br><span class="line">    Func&lt;int, int, int&gt; myLambda = lambda.Compile();</span><br><span class="line"></span><br><span class="line">    int result = myLambda(2, 3);</span><br><span class="line">    Console.WriteLine(&quot;result:&quot; + result.ToString());</span><br><span class="line"></span><br><span class="line">    Console.Read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后输出的结果：</p>
<p><img src="/2018/07/22/打造自己的linqProvider/lambda_result.png" alt="lambda_result"></p>
<p>这里我们只要简单的调用Compile方法就可以了，事实上在.NET Framework中是调用了一个名为ExpressionCompiler的内部类来做表达式目录树的执行（注意此处的Compiler不等同于编译器的编译）。另外，只能执行表示Lambda表达式的表达式目录树，即LambdaExpression或者Expression&lt;TDelegate&gt;类型。如果表达式目录树不是表示Lambda表达式，需要调用Lambda方法创建一个新的表达式。如下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    BinaryExpression body = Expression.Add(</span><br><span class="line">        Expression.Constant(2),</span><br><span class="line">        Expression.Constant(3));</span><br><span class="line"></span><br><span class="line">    Expression&lt;Func&lt;int&gt;&gt; expression = </span><br><span class="line">        Expression.Lambda&lt;Func&lt;int&gt;&gt;(body, null);</span><br><span class="line"></span><br><span class="line">    Func&lt;int&gt; lambda = expression.Compile();</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(lambda());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="访问与修改表达式目录树"><a href="#访问与修改表达式目录树" class="headerlink" title="访问与修改表达式目录树"></a>访问与修改表达式目录树</h2><p>在.NET Framework中，提供了一个抽象的表达式目录树访问类ExpressionVisitor，但它是一个internal的，我们不能直接访问。幸运的是，在MSDN中微软给出了ExpressionVisitor类的实现，我们可以直接拿来使用。该类是一个抽象类，微软旨在让我们在集成ExpressionVisitor的基础上，实现自己的表达式目录树访问类。现在我们来看简单的表达式目录树：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    Expression&lt;Func&lt;int, int, int&gt;&gt; lambda = (a, b) =&gt; a + b * 2;</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(lambda.ToString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出后为：</p>
<p><img src="/2018/07/22/打造自己的linqProvider/result2.png" alt="result2"></p>
<p>现在我们想要修改表达式目录树，让它表示的Lambda表达式为(a,b)=&gt;(a - (b * 2))，这时就需要编写自己的表达式目录树访问器，如下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class OperationsVisitor : ExpressionVisitor</span><br><span class="line">&#123;</span><br><span class="line">    public Expression Modify(Expression expression)</span><br><span class="line">    &#123;</span><br><span class="line">        return Visit(expression);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected override Expression VisitBinary(BinaryExpression b)</span><br><span class="line">    &#123;</span><br><span class="line">        if (b.NodeType == ExpressionType.Add)</span><br><span class="line">        &#123;</span><br><span class="line">            Expression left = this.Visit(b.Left);</span><br><span class="line">            Expression right = this.Visit(b.Right);</span><br><span class="line">            return Expression.Subtract(left,right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return base.VisitBinary(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用表达式目录树访问器来修改表达式目录树，如下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    Expression&lt;Func&lt;int, int, int&gt;&gt; lambda = (a, b) =&gt; a + b * 2;</span><br><span class="line"></span><br><span class="line">    var operationsVisitor = new OperationsVisitor();</span><br><span class="line">    Expression modifyExpression = operationsVisitor.Modify(lambda);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(modifyExpression.ToString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2018/07/22/打造自己的linqProvider/result3.png" alt="result3"></p>
<p>似乎我们是修改表达式目录树，其实也不全对，我们只是修改表达式目录树的一个副本而已，因为表达式目录树是不可变的，我们不能直接修改表达式目录树，看看上面的OperationsVisitor类的实现大家就知道了，在修改过程中复制了表达式目录树的节点。</p>
<h2 id="为什么需要表达式目录树"><a href="#为什么需要表达式目录树" class="headerlink" title="为什么需要表达式目录树"></a>为什么需要表达式目录树</h2><p>就拿LINQ to SQL为例</p>
<p><img src="/2018/07/22/打造自己的linqProvider/linq_to_sql.png" alt="linq_to_sql"></p>
<p>当我们在C#语言中编写一个查询表达式时，它将返回一个IQueryable类型的值，在该类型中包含了两个很重要的属性Expression和Provider，如下面的代码：</p>
<p><img src="/2018/07/22/打造自己的linqProvider/IQueryAble.png" alt="IQueryAble"></p>
<p>我们编写的查询表达式，将封装为一种抽象的数据结构，这个数据结构就是表达式目录树，当我们在使用上面返回的值时，编译器将会以该值所期望的方式进行翻译，这种方式就是由Expression和Provider来决定。可以看到，这样将会非常的灵活且具有良好的可扩展性，有了表达式目录树，可以自由的编写自己的Provider，去查询我们希望的数据源。经常说LINQ为访问各种不同的数据源提供了一种统一的编程方式，其奥秘就在这里。然而需要注意的是LINQ to Objects并不需要任何特定的LINQ Provider，因为它并不翻译为表达式目录树，后面会说到这一点。</p>
<h2 id="IEnumerable-lt-T-gt-接口"><a href="#IEnumerable-lt-T-gt-接口" class="headerlink" title="IEnumerable&lt;T&gt;接口"></a>IEnumerable&lt;T&gt;接口</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    List&lt;String&gt; myList = new List&lt;String&gt;() &#123; &quot;a&quot;, &quot;ab&quot;, &quot;cd&quot;, &quot;bd&quot; &#125;;</span><br><span class="line"></span><br><span class="line">    IEnumerable&lt;String&gt; query = from s in myList</span><br><span class="line">                where s.StartsWith(&quot;a&quot;)</span><br><span class="line">                select s;</span><br><span class="line"></span><br><span class="line">    foreach (String s in query)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Console.Read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2018/07/22/打造自己的linqProvider/result4.png" alt="result4"></p>
<p>为什么在LINQ to Objects中返回的是IEnumerable<t>类型的数据而不是IQueryable<t>呢？<br>在LINQ to Objects中查询表达式或者Lambda表达式并不翻译为表达式目录树，因为LINQ to Objects查询的都是实现了IEnmerable<t>接口的数据，所以查询表达式或者Lambda表达式都可以直接转换为.NET代码来执行，无需再经过转换为表达式目录这一步，这也是LINQ to Objects比较特殊的地方，它不需要特定的LINQ Provider。我们可以看一下IEnumerable<t>接口的实现，它里面并没有Expression和Provider这样的属性，如下图所示：</t></t></t></t></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface IEnumerable&lt;T&gt;:Ienumerable</span><br><span class="line">&#123;</span><br><span class="line">    IEnumerator&lt;T&gt; GetEnumerator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于LINQ to Objects中所有的标准查询操作符都是通过扩展方法来实现的，它们在抽象类Enumerable中定义，如其中的Where扩展方法如下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public static class Enumerable</span><br><span class="line">&#123;</span><br><span class="line">    public static IEnumerable&lt;TSource&gt; Where&lt;TSource&gt;(</span><br><span class="line">        this IEnumerable&lt;TSource&gt; source, </span><br><span class="line">        Func&lt;TSource, bool&gt; predicate)</span><br><span class="line">    &#123;</span><br><span class="line">        if (source == null)</span><br><span class="line">        &#123;</span><br><span class="line">            throw Error.ArgumentNull(&quot;source&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (predicate == null)</span><br><span class="line">        &#123;</span><br><span class="line">            throw Error.ArgumentNull(&quot;predicate&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return WhereIterator&lt;TSource&gt;(source, predicate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static IEnumerable&lt;TSource&gt; Where&lt;TSource&gt;(</span><br><span class="line">        this IEnumerable&lt;TSource&gt; source, </span><br><span class="line">        Func&lt;TSource, int, bool&gt; predicate)</span><br><span class="line">    &#123;</span><br><span class="line">        if (source == null)</span><br><span class="line">        &#123;</span><br><span class="line">            throw Error.ArgumentNull(&quot;source&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (predicate == null)</span><br><span class="line">        &#123;</span><br><span class="line">            throw Error.ArgumentNull(&quot;predicate&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return WhereIterator&lt;TSource&gt;(source, predicate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到这里方法的参数Func<tsource>系列委托，而非Expression&lt;Func<tsource>&gt;，在本文的后面，你将看到，IQueryable接口的数据，这些扩展方法的参数都是Expression&lt;Func<tsource>&gt;.</tsource></tsource></tsource></p>
<p>同样还有一点需要说明的是，在IEnumerable<t>中提供了一组扩展方法AsQueryable()，可以用来把一个IEnumerable<t>类型的数据转换为IQueryable<t>类型，如下代码所示：</t></t></t></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    var myList = new List&lt;String&gt;() </span><br><span class="line">                &#123; &quot;a&quot;, &quot;ab&quot;, &quot;cd&quot;, &quot;bd&quot; &#125;.AsQueryable&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    IQueryable&lt;String&gt; query = from s in myList</span><br><span class="line">                where s.StartsWith(&quot;a&quot;)</span><br><span class="line">                select s;</span><br><span class="line"></span><br><span class="line">    foreach (String s in query)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Console.Read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行这段代码，虽然它的输出结果与上面的示例完全相同，但它们查询的机制却完全不同：</p>
<h2 id="IQueryable-lt-T-gt-接口"><a href="#IQueryable-lt-T-gt-接口" class="headerlink" title="IQueryable&lt;T&gt;接口"></a>IQueryable&lt;T&gt;接口</h2><p><img src="/2018/07/22/打造自己的linqProvider/IQueryable定义.png" alt="IQueryable定义"></p>
<p>这里有两个很重要的属性Expression和Provider，分别表示获取与IQueryable 的实例关联的表达式目录树和获取与此数据源关联的查询提供程序，我们所有定义在查询表达式中方法调用或者Lambda表达式都将由该Expression属性表示，而最终会由Provider表示的提供程序翻译为它所对应的数据源的查询语言，这个数据源可能是数据库，XML文件或者是WebService等。该接口非常重要，在我们自定义LINQ Provider中必须要实现这个接口。同样对于IQueryable的标准查询操作都是由Queryable中的扩展方法来实现的，如下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public static class Queryable</span><br><span class="line">&#123;</span><br><span class="line">    public static IQueryable&lt;TSource&gt; Where&lt;TSource&gt;(this IQueryable&lt;TSource&gt; source, </span><br><span class="line">            Expression&lt;Func&lt;TSource, bool&gt;&gt; predicate)</span><br><span class="line">    &#123;</span><br><span class="line">        if (source == null)</span><br><span class="line">        &#123;</span><br><span class="line">            throw Error.ArgumentNull(&quot;source&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (predicate == null)</span><br><span class="line">        &#123;</span><br><span class="line">            throw Error.ArgumentNull(&quot;predicate&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return source.Provider.CreateQuery&lt;TSource&gt;(</span><br><span class="line">            Expression.Call(null, ((MethodInfo) MethodBase.GetCurrentMethod())</span><br><span class="line">            .MakeGenericMethod(new Type[] &#123; typeof(TSource) &#125;), </span><br><span class="line">            new Expression[] &#123; source.Expression, Expression.Quote(predicate) &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static IQueryable&lt;TSource&gt; Where&lt;TSource&gt;(this IQueryable&lt;TSource&gt; source,</span><br><span class="line">        Expression&lt;Func&lt;TSource, int, bool&gt;&gt; predicate)</span><br><span class="line">    &#123;</span><br><span class="line">        if (source == null)</span><br><span class="line">        &#123;</span><br><span class="line">            throw Error.ArgumentNull(&quot;source&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (predicate == null)</span><br><span class="line">        &#123;</span><br><span class="line">            throw Error.ArgumentNull(&quot;predicate&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return source.Provider.CreateQuery&lt;TSource&gt;(</span><br><span class="line">            Expression.Call(null, ((MethodInfo) MethodBase.GetCurrentMethod())</span><br><span class="line">            .MakeGenericMethod(new Type[] &#123; typeof(TSource) &#125;), </span><br><span class="line">            new Expression[] &#123; source.Expression, Expression.Quote(predicate) &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后还有一点，如果我们定义的查询需要支持Orderby等操作，还必须实现IOrderedQueryable&lt;T&gt; 接口，它继承自IQueryable&lt;T&gt;，如下图所示：</p>
<p><img src="/2018/07/22/打造自己的linqProvider/IOrderedQueryable.png" alt="IOrderedQueryable"></p>
<h2 id="IQueryProvider接口"><a href="#IQueryProvider接口" class="headerlink" title="IQueryProvider接口"></a>IQueryProvider接口</h2><p>在认识了IQueryable接口之后，我们再来看看在自定义LINQ Provider中另一个非常重要的接口IQueryProvider。它的定义如下图所示：</p>
<p><img src="/2018/07/22/打造自己的linqProvider/IQueryProvider.png" alt="IQueryProvider"></p>
<p>看到这里两组方法的参数，其实大家已经可以知道，Provider负责执行表达式目录树并返回结果。如果是LINQ to SQL的Provider，则它会负责把表达式目录树翻译为T-SQL语句并并传递给数据库服务器，并返回最后的执行的结果；如果是一个Web Service的Provider，则它会负责翻译表达式目录树并调用Web Service，最终返回结果。<br>这里四个方法其实就两个操作CreateQuery和Execute（分别有泛型和非泛型），CreateQuery方法用于构造一个 IQueryable<t> 对象，该对象可计算指定表达式目录树所表示的查询，返回的结果是一个可枚举的类型，；而Execute执行指定表达式目录树所表示的查询，返回的结果是一个单一值。自定义一个最简单的LINQ Provider，至少需要实现IQueryable<t>和IQueryProvider两个接口，在下篇文章中，你将看到一个综合的实例。</t></t></p>
<h2 id="扩展LINQ的两种方式"><a href="#扩展LINQ的两种方式" class="headerlink" title="扩展LINQ的两种方式"></a>扩展LINQ的两种方式</h2><p>通过前面的讲解，我们可以想到，对于LINQ的扩展有两种方式，一是借助于LINQ to Objects，如果我们所做的查询直接在.NET代码中执行，就可以实现IEnumerable<t>接口，而无须再去实现IQueryable并编写自定义的LINQ Provider，如.NET中内置的List<t>等。如我们可以编写一段简单自定义代码：</t></t></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class MyData&lt;T&gt; : IEnumerable&lt;T&gt;</span><br><span class="line">                where T : class</span><br><span class="line">&#123;</span><br><span class="line">    public IEnumerator&lt;T&gt; GetEnumerator()</span><br><span class="line">    &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IEnumerator IEnumerable.GetEnumerator()</span><br><span class="line">    &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 其它成员</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种扩展LINQ的方式当然就是自定义LINQ Provider了，我们需要实现IQueryable<t>和IQueryProvider两个接口，下面先给出一段简单的示意代码，在下一篇中我们将完整的来实现一个LINQ Provider。如下代码所示：</t></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">public class QueryableData&lt;TData&gt; : IQueryable&lt;TData&gt;</span><br><span class="line">&#123;</span><br><span class="line">    public QueryableData()</span><br><span class="line">    &#123;</span><br><span class="line">        Provider = new TerryQueryProvider();</span><br><span class="line">        Expression = Expression.Constant(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public QueryableData(TerryQueryProvider provider, </span><br><span class="line">        Expression expression)</span><br><span class="line">    &#123;</span><br><span class="line">        if (provider == null)</span><br><span class="line">        &#123;</span><br><span class="line">            throw new ArgumentNullException(&quot;provider&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (expression == null)</span><br><span class="line">        &#123;</span><br><span class="line">            throw new ArgumentNullException(&quot;expression&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!typeof(IQueryable&lt;TData&gt;).IsAssignableFrom(expression.Type))</span><br><span class="line">        &#123;</span><br><span class="line">            throw new ArgumentOutOfRangeException(&quot;expression&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Provider = provider;</span><br><span class="line">        Expression = expression;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public IQueryProvider Provider &#123; get; private set; &#125;</span><br><span class="line">    public Expression Expression &#123; get; private set; &#125;</span><br><span class="line"></span><br><span class="line">    public Type ElementType</span><br><span class="line">    &#123;</span><br><span class="line">        get &#123; return typeof(TData); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public IEnumerator&lt;TData&gt; GetEnumerator()</span><br><span class="line">    &#123;</span><br><span class="line">        return (Provider.Execute&lt;IEnumerable&lt;TData&gt;&gt;(Expression)).GetEnumerator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IEnumerator IEnumerable.GetEnumerator()</span><br><span class="line">    &#123;</span><br><span class="line">        return (Provider.Execute&lt;IEnumerable&gt;(Expression)).GetEnumerator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TerryQueryProvider : IQueryProvider</span><br><span class="line">&#123;</span><br><span class="line">    public IQueryable CreateQuery(Expression expression)</span><br><span class="line">    &#123;</span><br><span class="line">        Type elementType = TypeSystem.GetElementType(expression.Type);</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            return (IQueryable)Activator.CreateInstance(</span><br><span class="line">                typeof(QueryableData&lt;&gt;).MakeGenericType(elementType),</span><br><span class="line">                new object[] &#123; this, expression &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        catch</span><br><span class="line">        &#123;</span><br><span class="line">            throw new Exception();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public IQueryable&lt;TResult&gt; CreateQuery&lt;TResult&gt;(Expression expression)</span><br><span class="line">    &#123;</span><br><span class="line">        return new QueryableData&lt;TResult&gt;(this, expression);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public object Execute(Expression expression)</span><br><span class="line">    &#123;</span><br><span class="line">        // ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public TResult Execute&lt;TResult&gt;(Expression expression)</span><br><span class="line">    &#123;</span><br><span class="line">        // ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这两个接口都没有完成，这里只是示意性的代码，如果实现了这两个接口，我们就可以像下面这样使用了（当然这样的使用是没有意义的，这里只是为了演示）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    QueryableData&lt;String&gt; mydata = new QueryableData&lt;String&gt; &#123; </span><br><span class="line">        &quot;TerryLee&quot;,</span><br><span class="line">        &quot;Cnblogs&quot;,</span><br><span class="line">        &quot;Dingxue&quot;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var result = from d in mydata</span><br><span class="line">                 select d;</span><br><span class="line">    foreach (String item in result)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在再来分析一下这个执行过程，首先是实例化QueryableData<string>，同时也会实例化TerryQueryProvider；当执行查询表达式的时候，会调用TerryQueryProvider中的CreateQuery方法，来构造表达式目录树，此时查询并不会被真正执行（即延迟加载），只有当我们调用GetEnumerator方法，上例中的foreach，此时会调用TerryQueryProvider中的Execute方法，此时查询才会被真正执行，如下图所示：</string></p>
<p><img src="/2018/07/22/打造自己的linqProvider/执行过程.png" alt="执行过程"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/22/打造自己的linqProvider/" data-id="cjo6hnxu9001aq8uqm7h7a6vr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/08/08/理解JavaScript中的异步/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          理解JavaScript中的异步
        
      </div>
    </a>
  
  
    <a href="/2018/07/21/CSS入门及提高/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">CSS入门及提高</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/学习笔记/">学习笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/学习笔记/" style="font-size: 10px;">学习笔记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/09/30/权限系统/">权限系统</a>
          </li>
        
          <li>
            <a href="/2018/08/16/CSS-Web高级程序设计/">CSS-Web高级程序设计</a>
          </li>
        
          <li>
            <a href="/2018/08/11/Web前端开发环境搭建/">Web前端开发环境搭建</a>
          </li>
        
          <li>
            <a href="/2018/08/09/JQuery源码解读/">JQuery源码解读</a>
          </li>
        
          <li>
            <a href="/2018/08/08/Emmet语法/">Emmet语法</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>